C++ 函数调用本质上是在做：给函数形参分配内存，把实参的值复制进去。

区别就在于：

> “复制什么？”

- 值传递 → 复制 **变量的值**
- 指针传递 → 复制 **地址**
- 引用传递 → 不复制，只给实参起别名（语义上）

------

# 🧪 【C++ 参数传递语义 测试卷】

> 值传递 vs 引用传递 vs 指针传递

------

## Part A：基础判断题（10 题）

判断：**调用结束后，外部变量是否会被修改？是否合法？**
 写出“会 / 不会 + 合法 / 不合法 + 简要原因”。

------

### 1.

```cpp
void foo(int x) {
    x = 100;
}

int a = 10;
foo(a);
// a ?
```

------

### 2.

```cpp
void foo(int& x) {
    x = 100;
}

int a = 10;
foo(a);
// a ?
```

------

### 3.

```cpp
void foo(int* x) {
    *x = 100;
}

int a = 10;
foo(&a);
// a ?
```

------

### 4.

```cpp
void foo(int* x) {
    x = nullptr;
}

int a = 10;
int* p = &a;
foo(p);
// p ?
```

------

### 5.

```cpp
void foo(int*& x) {
    x = nullptr;
}

int a = 10;
int* p = &a;
foo(p);
// p ?
```

------

### 6.

```cpp
void foo(int& x) {
    int b = 20;
    x = b;
}

int a = 10;
foo(a);
// a ?
```

------

### 7.

```cpp
void foo(int* x) {
    int b = 20;
    x = &b;
}

int a = 10;
int* p = &a;
foo(p);
// p 指向谁？p 合法吗？
```

------

### 8.

⭐ 正确答案（必须掌握）：

✔ p 最终指向了“已经消失的局部变量 b”

也就是说：

> **p 变成了“悬空指针（dangling pointer）”。**

✔ 不会编译报错

这是 **运行时危险，不是编译时错误**。

⭐ x=&b 和 *x=b 的区别：

- `x = &b` → 修改指针本体 → 改 p
- `*x = b` → 修改 p 指向的内容 → 改 a

这两个本质完全不同。

```cpp
void foo(int*& x) {
    int b = 20;
    x = &b;
}

int a = 10;
int* p = &a;
foo(p);
// p 指向谁？这样做存在什么问题？
```

------

### 9.

⭐ 正确答案：

✔ foo(a) 合法

✔ foo(5) 也合法！

⭐ 为什么 foo(5) 合法？

因为：

> **只有 const 引用可以绑定到临时量、字面量**

 C++ 会生成一个隐藏的临时变量：

```cpp
int temp = 5;
const int& r = temp;
```

```cpp
void foo(const int& x) {
    // ...
}

int a = 10;
foo(a);        // OK?
foo(5);        // OK?
```

------

### 10.

指针可以接受：

- 正常地址
- 空指针
- nullptr 字面量

```cpp
void foo(int* x) {
    // ...
}

int* p = nullptr;
foo(p);        // OK?
foo(nullptr);  // OK?
```

------

## Part B：输出题（8 题）

------

### 11.

```cpp
void foo(int x) {
    x += 5;
    cout << "in foo: " << x << endl;
}

int a = 10;
foo(a);
cout << "after: " << a << endl;
```

> 输出？

------

### 12.

```cpp
void foo(int& x) {
    x += 5;
    cout << "in foo: " << x << endl;
}

int a = 10;
foo(a);
cout << "after: " << a << endl;
```

------

### 13.

```cpp
void foo(int* x) {
    *x += 5;
    cout << "in foo: " << *x << endl;
}

int a = 10;
foo(&a);
cout << "after: " << a << endl;
```

------

### 14.

```cpp
void foo(int* x) {
    int b = 20;
    x = &b;
    *x = 30;
    cout << "in foo: " << *x << endl;
}

int a = 10;
int* p = &a;
foo(p);
cout << "after: " << a << " " << *p << endl;
```

------

### 15.

编译 ✔ 能过

运行：**未定义行为（UB）**，可能：

- 打印 30
- 打印乱七八糟的数字
- 崩溃

```cpp
void foo(int*& x) {
    int b = 20;
    x = &b;
    *x = 30;
    cout << "in foo: " << *x << endl;
}

int a = 10;
int* p = &a;
foo(p);
cout << "after: " << *p << endl;
```

------

### 16.

```cpp
void foo(int*& x) {
    x = new int(42);
}

int* p = nullptr;
foo(p);
cout << *p << endl;
```

------

### 17.

```cpp
void foo(vector<int> v) {
    v.push_back(100);
}

void bar(vector<int>& v) {
    v.push_back(200);
}

vector<int> a = {1, 2, 3};
foo(a);
bar(a);
for (int x : a) cout << x << " ";
```

------

### 18.

```cpp
void foo(const vector<int>& v) {
    // v.push_back(100);  // 这行如果取消注释会怎样？
    cout << v.size() << endl;
}

vector<int> a = {1, 2, 3};
foo(a);
```

------

## Part C：概念理解题（7 题）

------

### 19.

分别用 **一句话**说明：

- 值传递的本质是什么？
- 引用传递的本质是什么？形参是实参的别名（Alias），与实参共享同一块内存。
- 指针传递的本质是什么？

------

### 20.

为什么说“**指针传递本质上还是值传递**”？

（提示：到底拷贝了什么？）

------

### 21.

什么时候你更倾向于用 **引用传递** 而不是指针传递？
 请至少说出 **两种场景**。

* 需要修改实参的值（原变量）
* 需要避免对象的大拷贝（如 vector、map）

------

### 22.

什么时候你更倾向于用 **指针传递** 而不是引用传递？
 请至少说出 **两种场景**。

* 对象可选（可能是 nullptr）
* 需要改变“指向谁”（改变实参指针）
* 链表 / 树操作需要区分 null vs 非 null

------

### 23.

下面两个函数原型语义上有什么区别？

```cpp
void foo(Node* root);
void foo(Node*& root);
```

在什么情况下应该用第二种？

✔ `void foo(Node* root)`

> 传的是指针值（地址）的拷贝。
>  在函数内修改 root 不会影响实参 root。
>  但可以通过 *root 修改节点内容。

✔ `void foo(Node*& root)`

> root 是外部指针的别名 → 修改 root = xxx 会影响实参。
>  常用于 **修改链表/树的根节点**。

------

### 24.

对于一个很大的 `vector<int>`，以下三种函数参数写法各有什么特点（拷贝？能否修改？）？

```cpp
void foo(vector<int> v);
void foo(vector<int>& v);
void foo(const vector<int>& v);
```

------

### 25.

为什么很多 C++ 标准库函数习惯使用 `const T&` 作为参数，而不是 `T` 或 `T*`？

✔ 1. 避免大对象拷贝（性能）

STL 中的 container（vector、map）很大，传值会 O(n) 拷贝。

✔ 2. const 表示“不修改此参数”，语义更清晰

STL 函数多数是只读行为，如：

- `find`
- `sort`（内部修改拷贝，不修改原容器）
- `lower_bound`
- `operator<`

✔ 3. const T& 能绑定字面量 和 临时变量

例如：

```
foo(5);        // const int& OK
foo({1,2,3});  // const vector<int>& OK
```

✔ 4. 可接受左值 / 右值

值传递不能接收大临时对象的右值（效率差）。

------

# ✅ 用法建议

你可以像上次那样：

- 先做 **Part A**，把答案发给我，我逐题给你批
- 再做 Part B、Part C

或者你也可以一口气全部做完，我给你一轮“总评 + 深度解析”。

什么时候准备好就把你的答案发给我（doge）。