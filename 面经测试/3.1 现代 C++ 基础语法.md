3.1 è¿™ä¸€å°èŠ‚å…¶å®å°±ä¸‰ä»¶å®ï¼š**autoã€èŒƒå›´ forã€lambda**ï¼Œè¿™ä¸‰æ ·é…åˆ STLï¼ŒåŸºæœ¬æ’‘èµ·ä½ åˆ·é¢˜/å†™ EDA C++ çš„ 80% æ—¥å¸¸ã€‚
 ä½ å¤©å¤©åˆ·åŠ›æ‰£ï¼Œè¿™å—ç»å¯¹æ˜¯â€œæåˆ†åŒºâ€ï¼Œè€Œä¸”å­¦èµ·æ¥å¾ˆæœ‰æˆå°±æ„Ÿã€‚

------

## ä¸€ã€`auto`ï¼šä¸æ˜¯ä¸ºäº†å·æ‡’ï¼Œè€Œæ˜¯ä¸ºäº†æ´»ä¸‹å» ğŸ˜†

### 1.1 `auto` æ˜¯ä»€ä¹ˆï¼Ÿ

ä¸€å¥è¯ï¼š**è®©ç¼–è¯‘å™¨å¸®ä½ æ¨å¯¼ç±»å‹**ã€‚

```cpp
int x = 10;
auto a = x;       // a æ˜¯ int
double y = 3.14;
auto b = y;       // b æ˜¯ double
```

**å®ƒä¸æ˜¯åŠ¨æ€ç±»å‹**ï¼ˆä¸æ˜¯ Python é‚£ç§ï¼‰ï¼š

- ç±»å‹åœ¨**ç¼–è¯‘æœŸå°±ç¡®å®šäº†**ï¼Œè·Ÿæ‰‹å†™ `int` / `double` ä¸€æ ·ã€‚
- åªæ˜¯ä½ ä¸å†™å‡ºæ¥ï¼Œè®©ç¼–è¯‘å™¨å¸®ä½ ç®—ã€‚

### 1.2 çœŸå®ç”¨é€”ï¼šæ¨¡æ¿ / è¿­ä»£å™¨å¤ªé•¿äº†

ä½ è‚¯å®šè§è¿‡è¿™ç§ï¼š

```cpp
std::vector<std::pair<int, int>> edges;
for (std::vector<std::pair<int, int>>::iterator it = edges.begin();
     it != edges.end(); ++it) {
    // ...
}
```

æ”¹æˆï¼š

```cpp
for (auto it = edges.begin(); it != edges.end(); ++it) {
    // ...
}
```

å†é…åˆèŒƒå›´ forï¼ˆåé¢è®²ï¼‰ï¼Œç”šè‡³ï¼š

```cpp
for (auto& [u, v] : edges) {
    // ...
}
```

åœ¨ EDA / LeetCode é‡Œï¼Œç»å¸¸æœ‰è¿™ç§ç±»å‹ï¼š

```cpp
std::unordered_map<std::string, std::vector<int>>
```

è¿™ç§å®Œå…¨æ²¡å¿…è¦æ‰‹å†™ä¸€é•¿ä¸²ï¼Œ**auto æ•‘å‘½**ã€‚

------

### 1.3 ä¸€ä¸ªè¶…é‡è¦çš„å‘ï¼š`auto` ä¼šâ€œåƒæ‰â€é¡¶å±‚ const / å¼•ç”¨

è®°ä½ä¸€å¥å£è¯€ï¼š

> **auto ä¼šæ‰”æ‰é¡¶å±‚ const å’Œå¼•ç”¨ï¼›æƒ³ä¿ç•™ï¼Œå°±è‡ªå·±å†™ä¸Šå»ã€‚**

ä¾‹å­ï¼š

```cpp
int x = 10;
const int cx = x;
const int& rx = x;

auto a = cx; // a æ˜¯ intï¼ˆconst è¢«åƒæ‰ï¼‰
auto b = rx; // b è¿˜æ˜¯ intï¼ˆå¼•ç”¨ä¹Ÿè¢«åƒæ‰ï¼‰
```

æ‰€ä»¥æ¨èå†™æ³•æ˜¯ï¼š

- åªè¯»éå†ï¼š`const auto&`
- è¦æ”¹å…ƒç´ ï¼š`auto&`
- éœ€è¦æŒ‡é’ˆï¼š`auto*`

ä¾‹å­ï¼ˆåŠ›æ‰£å¸¸è§ï¼‰ï¼š

```cpp
std::vector<int> nums = {1,2,3};

// åªè¯»éå†
for (const auto& v : nums) {
    // v åªè¯»å¼•ç”¨ï¼Œä¸æ‹·è´
}

// éœ€è¦å°±åœ°ä¿®æ”¹
for (auto& v : nums) {
    v *= 2;
}
```

æŒ‡é’ˆä¹Ÿç±»ä¼¼ï¼š

```cpp
const int* p = &x;
auto q = p;        // q æ˜¯ const int*ï¼ˆåº•å±‚ const ä¿ç•™ï¼‰
```

> å°æ€»ç»“ï¼š
>
> - **é¡¶å±‚ const**ï¼ˆä¿®é¥°å˜é‡æœ¬èº«ï¼‰â†’ ä¼šè¢« auto åƒæ‰
> - **åº•å±‚ const**ï¼ˆä¿®é¥°æŒ‡å‘çš„å¯¹è±¡ï¼Œæ¯”å¦‚æŒ‡é’ˆæŒ‡å‘çš„ intï¼‰â†’ ä¼šä¿ç•™
> - `auto&` / `const auto&`ï¼šä¼šæŠŠ const **ä¿ç•™ä¸‹æ¥**

ç†è§£ä¸€éä»¥åï¼Œä½ å¯¹ `auto` çš„ææƒ§ä¼šæ¶ˆå¤±å¾ˆå¤šã€‚

------

### 1.4 å¤§æ‹¬å·åˆå§‹åŒ–çš„ä¸€ä¸ªå°å‘ï¼ˆäº†è§£ï¼‰

```cpp
auto x{1};       // x: int
auto y = {1};    // y: std::initializer_list<int>
```

åŸºæœ¬åŸåˆ™ï¼š**åˆ·é¢˜é‡Œé¿å¼€éªšæ“ä½œ**ï¼Œè€è€å®å®ç”¨ `auto x = 1;` å°±å¥½ã€‚

------

## äºŒã€Range-based forï¼ˆèŒƒå›´ forï¼‰ï¼šfor å¾ªç¯ç°ä»£åŒ–

3.1 é‡Œç¬¬äºŒä¸ªç‚¹å°±æ˜¯å®ƒï¼š

```cpp
for (const auto& node : nodes) {
    // ...
}
```

### 2.1 è¿™ç©æ„æœ¬è´¨æ˜¯ä»€ä¹ˆï¼Ÿ

ç¼–è¯‘å™¨ä¼šæŠŠå®ƒå±•å¼€æˆç±»ä¼¼ï¼š

```cpp
for (auto it = std::begin(nodes); it != std::end(nodes); ++it) {
    auto& node = *it;
    // ...
}
```

æ‰€ä»¥å®ƒé€‚ç”¨äº**ä»»ä½•æœ‰ `begin()` / `end()` çš„ä¸œè¥¿**ï¼š

- `vector`, `string`, `deque`
- `map`, `unordered_map`
- åŸç”Ÿæ•°ç»„
- è‡ªå·±å†™çš„å¸¦ `begin()` / `end()` çš„å®¹å™¨

------

### 2.2 ä¸‰ç§å¸¸è§å†™æ³•ï¼ˆä¸€å®šè¦ä¼šåŒºåˆ†ï¼‰

å‡è®¾ï¼š

```cpp
std::vector<int> nums = {1,2,3,4};
```

1. **å€¼éå†ï¼šæ‹·è´ä¸€ä»½**

```cpp
for (auto x : nums) {
    x *= 2;      // æ”¹çš„æ˜¯æ‹·è´ï¼Œä¸ä¼šå½±å“ nums
}
```

1. **å¼•ç”¨éå†ï¼šå¯ä»¥ä¿®æ”¹åŸå®¹å™¨**

```cpp
for (auto& x : nums) {
    x *= 2;      // ç›´æ¥æ”¹ nums é‡Œçš„å…ƒç´ 
}
```

1. **const å¼•ç”¨éå†ï¼šåªè¯»ï¼Œä¸æ‹·è´**

```cpp
for (const auto& x : nums) {
    std::cout << x << "\n";  // ä¸å…è®¸æ”¹ xï¼Œæ€§èƒ½åˆå¥½
}
```

åˆ·é¢˜æ¨èä¹ æƒ¯ï¼š

- é»˜è®¤ç”¨ `const auto&`ï¼ˆåªè¯»ã€å®‰å…¨ã€æ— æ‹·è´ï¼‰
- ç¡®å®šè¦æ”¹å®¹å™¨å…ƒç´  â†’ `auto&`
- å‡ ä¹ä¸è¦ç”¨çº¯ `auto`ï¼ˆä¼šå¤šä¸€æ¬¡æ‹·è´ï¼‰

------

### 2.3 éå† `map` / `unordered_map`

```cpp
std::unordered_map<std::string, int> mp;

// ä¼ ç»Ÿå†™æ³•
for (auto it = mp.begin(); it != mp.end(); ++it) {
    const std::string& key = it->first;
    int value = it->second;
}

// èŒƒå›´ for + pair
for (const auto& kv : mp) {
    const auto& key = kv.first;
    int value = kv.second;
}

// C++17 ç»“æ„åŒ–ç»‘å®šï¼ˆéå¸¸çˆ½ï¼‰
for (const auto& [key, value] : mp) {
    // ç›´æ¥ç”¨ key, value
}
```

å†™ EDA å›¾ã€åŠ›æ‰£å›¾è®ºé¢˜çš„æ—¶å€™ï¼Œä½ è‚¯å®šä¼šå†™ç±»ä¼¼ï¼š

```cpp
std::vector<std::vector<int>> adj;
for (int u = 0; u < n; ++u) {
    for (int v : adj[u]) {
        // ...
    }
}
```

è¿™ä¸€å¥—å°±æ˜¯ï¼š**å¤–å±‚æ™®é€š for ä¸‹æ ‡ï¼Œå†…å±‚èŒƒå›´ for éå†é‚»æ¥è¡¨**ã€‚å‡ ä¹æ˜¯å›¾è®ºâ€œæ¨¡æ¿å§¿åŠ¿â€ã€‚

------

## ä¸‰ã€Lambda è¡¨è¾¾å¼ï¼šç°ä»£ C++ çš„â€œåŒ¿åå‡½æ•°â€

ç¬¬ä¸‰ä¸ªæ ¸å¿ƒå°±æ˜¯ Lambdaã€‚åŸå‹ï¼š

```cpp
[capture](params) mutable -> return_type {
    body
};
```

å„éƒ¨åˆ†ï¼š

- `[capture]`ï¼šæ•è·å¤–éƒ¨å˜é‡ï¼Œåé¢é‡ç‚¹è®²
- `(params)`ï¼šå‚æ•°åˆ—è¡¨ï¼Œå¯ä»¥å†™ `int a, int b`ï¼Œä¹Ÿå¯ä»¥ `auto x, auto y`
- `mutable`ï¼šå…è®¸ä¿®æ”¹æŒ‰å€¼æ•è·çš„å˜é‡ï¼ˆå¹³æ—¶ä¸å¤ªç”¨ï¼‰
- `-> return_type`ï¼šè¿”å›å€¼ç±»å‹ï¼Œé€šå¸¸å¯ä»¥çœç•¥
- `{ body }`ï¼šå‡½æ•°ä½“

------

### 3.1 æœ€å¸¸è§å†™æ³•ï¼šç»™ `std::sort` å†™æ¯”è¾ƒå‡½æ•°

ç»å…¸ä¾‹å­ï¼ˆä½ è‚¯å®šå¤©å¤©è§ï¼‰ï¼š

```cpp
std::vector<int> nums;

// æŒ‰ç»å¯¹å€¼æ’åº
std::sort(nums.begin(), nums.end(),
          [](int a, int b) {
              return std::abs(a) < std::abs(b);
          });
```

å¦‚æœæ˜¯ EDA é‡Œçš„ç»“æ„ä½“ï¼š

```cpp
struct Net {
    double delay;
    // ...
};

std::vector<Net> nets;

std::sort(nets.begin(), nets.end(),
          [](const Net& a, const Net& b) {
              return a.delay < b.delay;
          });
```

> é¢è¯•å®˜é—®ï¼šâ€œä½ ä¼šä¸ä¼šç”¨ lambda ç»™ sort è‡ªå®šä¹‰æ’åºï¼Ÿâ€
>  åªè¦ä½ å†™å¾—å‡ºä¸Šé¢è¿™ç§ï¼Œç›´æ¥åŠ åˆ†ã€‚

------

### 3.2 æ•è·åˆ—è¡¨ `[capture]`ï¼šLambda çš„çµé­‚

å‡ ç§å¸¸è§æ–¹å¼ï¼š

1. **ä¸æ•è·ï¼š`[]`**

```cpp
auto f = [](int x) { return x * 2; };
std::cout << f(10);  // 20
```

1. **æŒ‰å€¼æ•è·ï¼š`[=]` æˆ– `[x]`**

```cpp
int base = 10;

auto f = [base](int x) {
    return x + base;  // ç”¨çš„æ˜¯ base çš„æ‹·è´
};
```

1. **æŒ‰å¼•ç”¨æ•è·ï¼š`[&]` æˆ– `[&x]`**

```cpp
int cnt = 0;
auto f = [&cnt](int x) {
    cnt += x;         // ç›´æ¥ä¿®æ”¹å¤–é¢çš„ cnt
};

f(1);
f(2);
// cnt == 3
```

1. **æ··åˆæ•è·ï¼š**

```cpp
int a = 1, b = 2;
auto f = [a, &b] {
    // a æ˜¯æ‹·è´ï¼Œb æ˜¯å¼•ç”¨
};
```

åˆ·é¢˜/å·¥ç¨‹é‡Œé¢ç®€å•ç”¨æ³•å»ºè®®ï¼š

- éœ€è¦è¯»å¤–éƒ¨å˜é‡ï¼Œä¸æ”¹ â†’ `[=]` å¤Ÿç”¨
- éœ€è¦æ”¹å¤–éƒ¨å˜é‡ï¼ˆä¾‹å¦‚ç»Ÿè®¡ç­”æ¡ˆï¼‰â†’ `[&]` æˆ–å…·ä½“å†™ `[&ans]`
- **ä¸è¦å›¾çœäº‹å…¨å®¶æ¡¶**ï¼šåœ¨å¤æ‚å·¥ç¨‹é‡Œï¼Œ`[=]` / `[&]` ä¼šè®©å¯è¯»æ€§å˜å·®ï¼Œæ¨èæ˜¾å¼åˆ—å‡ºéœ€è¦æ•è·çš„å˜é‡ã€‚

------

### 3.3 Lambda + sortï¼šç»“åˆæ•è·å¤–éƒ¨å‚æ•°

ä¾‹å­ï¼šæŒ‰æŸä¸ª `target` çš„è·ç¦»æ’åºï¼ˆåŠ›æ‰£å¾ˆå¸¸è§ï¼‰ï¼š

```cpp
int target = 10;
std::vector<int> nums = {7, 13, 9, 20};

std::sort(nums.begin(), nums.end(),
          [target](int a, int b) {
              return std::abs(a - target) < std::abs(b - target);
          });
```

EDA åœºæ™¯ï¼šæŒ‰æ—¶åº slack æ’åºï¼š

```cpp
double required_time;
std::vector<Net*> nets;

std::sort(nets.begin(), nets.end(),
          [required_time](Net* a, Net* b) {
              double slack_a = required_time - a->delay;
              double slack_b = required_time - b->delay;
              return slack_a < slack_b;
          });
```

------

### 3.4 æ³›å‹ Lambdaï¼ˆC++14+ï¼ŒåŠ›æ‰£å®ç”¨ï¼‰

å‚æ•°é‡Œå¯ä»¥ç”¨ `auto`ï¼š

```cpp
auto add = [](auto x, auto y) {
    return x + y;
};

add(1, 2);       // int
add(1.0, 2.5);   // double
```

ç»™ `priority_queue` å†™æ¯”è¾ƒå™¨æ—¶å¾ˆæ–¹ä¾¿ï¼š

```cpp
struct Node {
    int id;
    double dist;
};

auto cmp = [](const Node& a, const Node& b) {
    return a.dist > b.dist;  // å°æ ¹å †
};

std::priority_queue<Node, std::vector<Node>, decltype(cmp)> pq(cmp);
```

è¿™ä¸ªå†™æ³•ä½ åœ¨å›¾ç®—æ³•ï¼ˆDijkstra ç­‰ï¼‰é‡Œä¼šç”¨åˆ°å¾ˆå¤šã€‚

------

### 3.5 Lambda é€’å½’ï¼ˆäº†è§£ï¼‰

æœ‰æ—¶å€™ä½ æƒ³åœ¨ä¸€ä¸ªå‡½æ•°é‡Œå†™ä¸ªå±€éƒ¨ DFSï¼Œç”¨ Lambda ä¹Ÿèƒ½æï¼š

```cpp
std::function<void(int)> dfs;

dfs = [&](int u) {
    // ...
    for (int v : adj[u]) {
        dfs(v);
    }
};
```

æˆ–è€… C++14 çš„â€œè‡ªé€’å½’ Lambda æ¨¡æ¿æŠ€å·§â€ï¼ˆç¨å¾®é«˜çº§ç‚¹ï¼Œå…ˆçŸ¥é“æœ‰è¿™å›äº‹å°±å¥½ï¼‰ï¼š

```cpp
auto dfs = [&](auto&& self, int u) -> void {
    // ...
    for (int v : adj[u]) {
        self(self, v);
    }
};

dfs(dfs, 0);
```

é¢è¯•ä¸­è¯´å¾—å‡ºè¿™ç§å†™æ³•ï¼Œä¼šæ˜¾å¾—ä½ å¯¹ç°ä»£ C++ æ¯”è¾ƒç†Ÿã€‚

------

## å››ã€ç»“åˆä½ å½“å‰é˜¶æ®µçš„ä¸€ç‚¹ä½¿ç”¨ä¹ æƒ¯å»ºè®®

ç»™ä½ å‡ ä¸ªâ€œä»ä»Šå¤©å¼€å§‹å°±ç”¨èµ·æ¥â€çš„ä¹ æƒ¯ï¼š

1. **éå†å®¹å™¨ï¼š**
   - é»˜è®¤å†™ï¼š`for (const auto& x : container) { ... }`
   - è¦æ”¹å…ƒç´ å†å†™ï¼š`for (auto& x : container)`
2. **è¿­ä»£å™¨ / map / pair / tuple ç±»å‹å¾ˆé•¿æ—¶ï¼š**
   - åšå†³ç”¨ `auto` æˆ– `auto&`ï¼Œä¸è¦æ­»ç£•æŠŠç±»å‹å†™å‡ºæ¥ã€‚
3. **æ‰€æœ‰è‡ªå®šä¹‰æ’åº / å †æ¯”è¾ƒå™¨ï¼š**
   - ç»Ÿä¸€ç”¨ lambdaï¼š
     - `std::sort(..., [](const T& a, const T& b){ ... });`
     - `auto cmp = [](const T& a, const T& b){ ... }; priority_queue<..., decltype(cmp)> pq(cmp);`
4. **ä¸è¦æ»¥ç”¨ `auto`ï¼š**
   - å‡½æ•°è¿”å›å€¼ç±»å‹å¦‚æœå¾ˆç®€å•ï¼Œå»ºè®®å†™æ¸…æ¥šï¼Œæ¯”å¦‚ `int`, `double`ã€‚
   - åœ¨é‡è¦çš„çŠ¶æ€å˜é‡ä¸Šï¼ˆæ¯”å¦‚ DP æ•°ç»„çš„ç±»å‹ï¼‰ï¼Œé€‚å½“å†™æ˜ç±»å‹æ–¹ä¾¿é˜…è¯»ã€‚

------

## æœ€åï¼Œç»™ä½ ä¸€ç‚¹â€œä»Šæ—¥ç»ƒä¹ å°ä»»åŠ¡â€ ğŸ’ª

ä½ å¦‚æœæ„¿æ„ï¼Œå¯ä»¥ç¨å¾®åšä¸€ä¸‹è¿™å‡ ä¸ªå°ç»ƒä¹ ï¼ˆå’Œä½ æ¯å¤©åˆ· 1â€“2 é¢˜é¡ºæ‰‹ç»“åˆï¼‰ï¼š

1. éšä¾¿æŒ‘ **2 é“ä½ æœ€è¿‘å†™è¿‡çš„åŠ›æ‰£é¢˜**ï¼š
   - æŠŠæ‰€æœ‰æ™®é€š `for` + `i` è¿­ä»£ vector çš„åœ°æ–¹ï¼Œæ”¹æˆ**èŒƒå›´ for + const auto& / auto&**ã€‚
2. éšä¾¿æ‰¾ä¸€é“è¦æ’åºçš„é¢˜ï¼š
   - ç”¨ `std::sort` + **lambda è‡ªå®šä¹‰æ’åº**é‡å†™ä¸€éã€‚
3. æ‰¾ä¸€é“éœ€è¦ç”¨ `priority_queue` çš„é¢˜ï¼š
   - è‡ªå·±å†™ä¸€ä¸ª **lambda ä½œä¸ºæ¯”è¾ƒå™¨** çš„ç‰ˆæœ¬ã€‚

ä½ æŠŠè¿™å‡ ä¸ªä¹ æƒ¯åšæŒä¸€æ®µæ—¶é—´ï¼Œä½ å¯¹ 3.1 è¿™å—å°±ä¸æ˜¯â€œçŸ¥é“è¯­æ³•â€ï¼Œè€Œæ˜¯â€œæ‰‹æ„Ÿè‡ªåŠ¨å°±å†™å‡ºæ¥â€äº†ï¼Œè¿™ç§ç†Ÿç»ƒåº¦åœ¨é¢è¯•é‡Œéå¸¸åŠ åˆ†ã€‚

------

å¦‚æœä½ æ„¿æ„ï¼Œä¸‹ä¸€æ­¥æˆ‘å¯ä»¥å¸¦ä½ **æŒ‰â€œauto â†’ èŒƒå›´ for â†’ lambdaâ€é¡ºåºï¼Œå‡ºå‡ é“å°ç»ƒä¹ é¢˜**ï¼Œé…åˆä½ ç°åœ¨åœ¨åšçš„å…·ä½“åŠ›æ‰£é¢˜ç›®ï¼Œä¸€èµ·ä¼˜åŒ–å†™æ³•ã€‚ä½ å¯ä»¥ç›´æ¥æŠŠä¸€æ®µä½ æœ€è¿‘çš„é¢˜è§£ä»£ç å‘ç»™æˆ‘ï¼Œæˆ‘å¸®ä½ æŒ‰ 3.1 çš„æ€è·¯ä¸€èµ·é‡æ„ä¸€ç‰ˆã€‚