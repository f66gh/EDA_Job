好，咱就把你这节“3.4 常用算法”当成上课来讲一遍，再顺手扩展到一整套你面试能说的东西 👍

你给的提纲只有这几条：

> - `std::sort`、`std::reverse`
> - `std::lower_bound` / `std::upper_bound`

我按这个主线来，外加几个强相关的：`std::stable_sort`、`std::binary_search`、`std::equal_range`、`sort + unique` 去重套路。

------

## 0. 统一背景：头文件 & 迭代器要求

所有这些算法都在头文件 `<algorithm>` 里：

```cpp
#include <algorithm>
```

STL 算法都是“全局函数 + 迭代器”，基本形式：

```cpp
algorithm_name(first, last, ...);
```

- 作用范围是 `[first, last)` 左闭右开；
- 能不能用在某个容器上，取决于**迭代器类型**（是不是随机访问、至少前向等）；
- 大部分容器都可以用，但 **`std::sort` 要求随机访问迭代器**（vector / deque / array / string）。

------

## 1. `std::sort` —— 排序的核心八股

### 1.1 基本使用

```cpp
#include <algorithm>
#include <vector>

std::vector<int> v = {3, 1, 4};

std::sort(v.begin(), v.end());  // 默认从小到大
```

**默认排序规则**：

- 对内置类型：从小到大（使用 `<`）
- 对自定义类型：要求有 `operator<`

### 1.2 自定义比较函数

#### 写成函数对象 / 函数指针：

```cpp
bool cmp_desc(int a, int b) {
    return a > b;  // “a 应该排在 b 前面”？
}

std::sort(v.begin(), v.end(), cmp_desc);  // 降序
```

#### 写成 lambda（面试高频）：

```cpp
std::sort(v.begin(), v.end(),
          [](const Path& a, const Path& b) {
              return a.slack < b.slack;  // slack 小的排前面
          });
```

**记忆口诀**：

> `comp(a, b)` 返回 true，表示：**a 应该排在 b 前面**。

### 1.3 比较函数的要求（严格弱序）

这个是很多人忽略但面试爱问的点：

比较函数 `comp` 必须满足：

- **自反性**：`comp(x, x)` 必须是 `false`
- **传递性**：`comp(a, b)` && `comp(b, c)` ⇒ `comp(a, c)` 必须 true
- **不矛盾**：`comp(a, b)` 为真时，`comp(b, a)` 必须为假

比如**错误写法**：

```cpp
// 想让奇数在前、偶数在后，但没考虑大小顺序
bool bad_comp(int a, int b) {
    return (a % 2) < (b % 2);  // 只按奇偶排，不管大小
}
```

这样会让 sort 内部认为“有些元素互相比不出大小”，可能触发 UB（比如 `find` 找不到刚插入的，顺序乱七八糟）。
 实务中：比较函数一般是类似“`if (x != y) return x < y; else return...`”这种，天然满足严格弱序。

------

### 1.4 复杂度 & 迭代器要求

- 算法实现：多数标准库是“快排 + 堆排/插排 混合”，以保证最坏 O(n log n)。
- 复杂度：平均 O(n log n)，最坏 O(n log n)。
- 迭代器要求：**RandomAccessIterator**
  - ✅ `vector` / `deque` / `array` / `string`
  - ❌ `list` / `forward_list`
  - ❌ `map` / `unordered_map`（只能先拷贝到 vector 再 sort）

一句话八股总结：

> `std::sort` 是通用排序算法，要求随机访问迭代器，平均 & 最坏复杂度都是 O(n log n)，默认用 `<`，也可以传自定义比较器，必须满足严格弱序。

------

### 1.5 扩展：`std::stable_sort`

`std::stable_sort`：**稳定排序**，相等元素的相对顺序不变。

什么时候用？

- 先按 key1 排，再按 key2 排
   ➜ 如果第二次排序是稳定的，等价于“主 key2 + 次 key1”的联合排序。

举例（先按 `from`，后按 `slack`）：

```cpp
std::stable_sort(vec.begin(), vec.end(),
                 [](const Edge& a, const Edge& b) {
                     return a.from < b.from; // 第一次按 from 排
                 });

std::stable_sort(vec.begin(), vec.end(),
                 [](const Edge& a, const Edge& b) {
                     return a.slack < b.slack; // 第二次按 slack 排
                 });
```

最后结果：

- slack 越小越靠前；
- 同 slack 元素之间按 from 升序。

复杂度也是 O(n log n)，但常数比 `sort` 大一些。

------

## 2. `std::reverse` —— 简单但常用

### 2.1 基本用法

```cpp
#include <algorithm>
#include <vector>

std::vector<int> v = {1, 2, 3, 4};
std::reverse(v.begin(), v.end()); // v 变成 {4, 3, 2, 1}
```

- 时间复杂度 O(n)
- 要求：至少**双向迭代器**（`map`、`list`、`vector` 都可以）

### 2.2 常见组合

- 排序后想要**降序**：

  ```cpp
  std::sort(v.begin(), v.end());      // 升序
  std::reverse(v.begin(), v.end());   // 变成降序
  ```

  或者一开始就用 `sort` + 比较器降序。

- 反转字符串：

  ```cpp
  std::string s = "abc";
  std::reverse(s.begin(), s.end());   // "cba"
  ```

------

## 3. `std::lower_bound` / `std::upper_bound` —— 二分查找三件套之一

这俩是**在有序区间上做二分查找**的算法，原型（简化版）：

```cpp
template<class ForwardIt, class T>
ForwardIt lower_bound(ForwardIt first, ForwardIt last, const T& value);

template<class ForwardIt, class T>
ForwardIt upper_bound(ForwardIt first, ForwardIt last, const T& value);
```

前提条件：

> `[first, last)` 必须是按相同比较规则**有序**的，否则结果未定义。

### 3.1 lower_bound：第一个 ≥ value 的位置

```cpp
std::vector<int> v = {1, 3, 3, 5, 7};
auto it = std::lower_bound(v.begin(), v.end(), 3);
// it 指向第一个 3（下标 1）
```

- 如果所有元素都 `< value`，则返回 `last`。
- 时间复杂度：O(log n)

### 3.2 upper_bound：第一个 > value 的位置

```cpp
auto it2 = std::upper_bound(v.begin(), v.end(), 3);
// 指向 5（下标 3）
```

配合 `lower_bound`，可以快速得到：

- 所有等于 `value` 的元素区间是 `[lower_bound, upper_bound)`
- 个数是 `upper_bound - lower_bound`

### 3.3 二分查找常见四连击（扩展）

配套还有两个兄弟：

1. `std::binary_search`：只返回是否存在

   ```cpp
   bool exist = std::binary_search(v.begin(), v.end(), 3);
   ```

2. `std::equal_range`：**一次返回 lower 和 upper**

   ```cpp
   auto range = std::equal_range(v.begin(), v.end(), 3);
   auto first = range.first;  // lower_bound
   auto last  = range.second; // upper_bound
   ```

面试说法可以这样：

> 二分查找相关算法主要有四个：`lower_bound` 返回第一个 ≥ value 的位置，`upper_bound` 返回第一个 > value 的位置，`binary_search` 判断是否存在，`equal_range` 一次返回 `[lower, upper)` 区间；它们都要求区间是有序的，时间复杂度 O(log n)。

------

### 3.4 lower_bound 的典型用法：保持有序插入

假设你有一个**有序 vector**，希望插入新元素时仍保持有序：

```cpp
std::vector<int> v = {1, 3, 5, 7};
int x = 4;

auto it = std::lower_bound(v.begin(), v.end(), x);
v.insert(it, x);  // 插入之后 v = {1,3,4,5,7}
```

- `lower_bound` 找到第一个 ≥ x 的位置；
- 插入到这里即可保持有序。

在 STA / EDA 场景中：

> 做查表插值（例如电压、温度相关的 delay 表），常用 lower_bound 找到区间 `[x_i, x_{i+1})`，然后做插值。

------

## 4. 常用“套路扩展”：`sort + unique` 去重、`remove_if` + erase

虽然你笔记里没写，但这两个组合面试特别喜欢问，顺带记一下。

### 4.1 sort + unique 去重

目标：给一个 vector 去重（不要求保持原顺序）：

```cpp
std::vector<int> v = {3, 1, 3, 2, 1};

// 1. 排序
std::sort(v.begin(), v.end());  // {1,1,2,3,3}

// 2. unique 把重复元素“挤到后面”
auto it = std::unique(v.begin(), v.end()); // {1,2,3,?,?}

// 3. erase 删除尾部多余元素
v.erase(it, v.end());           // {1,2,3}
```

**记忆点**：

- `std::unique` 不是真正“删元素”，只是把不重复的元素往前挪，返回一个“新逻辑末尾”的迭代器；
- 真正删掉要配合 `erase` —— 这就是著名的 **erase-remove 惯用法** 的亲戚。

### 4.2 remove_if + erase（了解）

```cpp
v.erase(std::remove_if(v.begin(), v.end(),
                       [](int x) { return x % 2 == 0; }),
        v.end());
```

- 删除所有偶数；
- 原因类似：`remove_if` 把不要的元素挤到后面，再用 `erase` 物理删除。

------

## 5. 和关联容器的关系（容易混）

你前面学了 3.3 关联容器，这里说明一点：

- `std::map` / `std::set` 自身就有成员函数：

  ```cpp
  auto it = m.lower_bound(key);
  auto it2 = m.upper_bound(key);
  auto p = m.equal_range(key);
  ```

  这些是**树上的操作**，复杂度 O(log n)。

- `<algorithm>` 里的 `std::lower_bound` / `std::upper_bound` 是**基于迭代器的泛型算法**，主要用在 `vector` 等线性序列上。

大多数情况下：

- 对 `vector` / `array`：用 `<algorithm>` 版本；
- 对 `map` / `set`：用成员函数版本（更高效，不用线性扫）。

------

## 6. 小结：给你一个“3.4 面试口述版”

你可以试着用自己的话复述下面这段（这是给面试官说的版本）：

> STL 算法主要通过迭代器操作区间，比如 `std::sort`、`std::reverse` 和 `std::lower_bound` / `upper_bound`。
>
> `std::sort` 在 `<algorithm>` 里，是一个需要**随机访问迭代器**的排序算法，一般用在 `vector`、`deque`、`array` 上，默认用 `<` 从小到大排，复杂度平均和最坏都是 O(n log n)，也可以传 lambda 做自定义比较，比较函数要满足严格弱序。
>
> `std::reverse` 比较简单，对 `[first, last)` 做原地反转，双向迭代器就够了，复杂度 O(n)。常见用法是排序后再 reverse 做降序，或者反转字符串。
>
> `std::lower_bound` 和 `std::upper_bound` 是基于二分查找的搜索算法，前提是区间按同样的比较规则有序。`lower_bound` 返回第一个 ≥ value 的迭代器，`upper_bound` 返回第一个 > value 的迭代器，时间复杂度 O(log n)，可以用来统计元素个数，也可以用来在有序 vector 里找到插入位置并保持有序。配套还有 `binary_search` 和 `equal_range`。
>
> 实战代码里常见的套路是：`sort + unique` 做去重，`remove_if + erase` 做过滤，这些都是 `<algorithm>` 里的通用算法加容器成员函数组合起来用。

------

如果你愿意，下一步可以：

- 你挑一个你最关心的场景（比如“STA 查表插值”或“路径按 slack 排序”），我给你写一段完整示例，把 `sort` + `lower_bound` 一起用出来；
- 或者我给你几道“3.4 算法 + 3.2 顺序容器 + 3.3 关联容器”综合小题，让你练习一下答题套路。

## 补充：容器和适配器的迭代器类型

在 C++ 标准库中，不同的容器和适配器提供不同类型的迭代器，每种迭代器类型有特定的操作和复杂度要求。根据算法的需要，选择合适的迭代器类型是非常重要的。

### 1. **容器迭代器类型**

#### **随机访问迭代器 (Random Access Iterator)**

支持对容器进行任意元素访问，能够像数组一样通过下标进行访问，并提供高效的算术运算（如 `+`、`-`）。常见于支持 `std::sort`、`std::lower_bound` 等要求随机访问迭代器的算法。

- **适用容器**：
  - `std::vector`
  - `std::array`
  - `std::deque`
- **支持的算法**：
  - `std::sort`
  - `std::reverse`
  - `std::lower_bound`
  - `std::upper_bound`
  - `std::binary_search`
  - `std::find`（支持随机访问容器时）

#### **双向迭代器 (Bidirectional Iterator)**

支持前进和后退，但不支持直接进行算术运算。适合于需要双向遍历的算法，如 `std::reverse` 和一些需要双向访问的操作。

- **适用容器**：
  - `std::list`
  - `std::set`
  - `std::map`
  - `std::multiset`
  - `std::multimap`
- **支持的算法**：
  - `std::reverse`
  - `std::find`
  - `std::for_each`
  - `std::remove`

#### **前向迭代器 (Forward Iterator)**

支持单向遍历，且只能向前移动。适用于算法中需要逐一访问容器元素，但不需要回退的场景。

- **适用容器**：
  - `std::forward_list`
  - `std::list`（同双向迭代器）
- **支持的算法**：
  - `std::find`
  - `std::for_each`
  - `std::remove_if`
  - `std::accumulate`

#### **输入迭代器 (Input Iterator)**

最基础的迭代器类型，只支持一次向前遍历，适用于只需读取元素的场景。

- **适用容器**：
  - `std::istream_iterator`（用于输入流）
  - `std::forward_list`（如果只需要访问一次元素）
- **支持的算法**：
  - `std::find`
  - `std::copy`

#### **输出迭代器 (Output Iterator)**

主要用于向容器中写入数据，不能反向访问，只支持写入操作。

- **适用容器**：
  - `std::ostream_iterator`（用于输出流）
- **支持的算法**：
  - `std::copy`
  - `std::transform`

### 2. **容器适配器的迭代器类型**

容器适配器（如栈、队列和优先队列）通常不直接暴露迭代器，而是通过特定的接口来访问元素。

#### **栈（stack）**

- **迭代器类型**：无迭代器（没有暴露元素的迭代器）
- **支持的操作**：只能通过 `push`, `pop`, `top` 来访问元素

#### **队列（queue）**

- **迭代器类型**：无迭代器（没有暴露元素的迭代器）
- **支持的操作**：只能通过 `push`, `pop`, `front`, `back` 来访问元素

#### **优先队列（priority_queue）**

- **迭代器类型**：无迭代器（没有暴露元素的迭代器）
- **支持的操作**：只能通过 `push`, `pop`, `top` 来访问元素

### 3. **算法和迭代器要求**

#### **`std::sort`**

- **要求的迭代器类型**：随机访问迭代器
  - 由于 `std::sort` 会使用快速排序（或其他排序算法），它需要支持通过 `+` 和 `-` 运算符进行随机访问，因此只支持随机访问迭代器。

#### **`std::reverse`**

- **要求的迭代器类型**：双向迭代器
  - 由于 `std::reverse` 需要从两端交换元素，因此需要双向迭代器来支持正向和反向的移动。

#### **`std::lower_bound` / `std::upper_bound`**

- **要求的迭代器类型**：随机访问

迭代器类型

- **`std::lower_bound` / `std::upper_bound`**：这些算法通过二分查找来查找元素，因此它们要求容器使用随机访问迭代器。二分查找算法的关键是能够直接跳跃到中间位置，这只有随机访问迭代器能够提供。

#### **`std::find`**

- **要求的迭代器类型**：前向迭代器
  - `std::find` 用于查找容器中的元素，它要求至少是前向迭代器，支持一次单向遍历。

#### **`std::for_each`**

- **要求的迭代器类型**：前向迭代器
  - `std::for_each` 用于对容器中的每个元素应用一个给定的函数，因此它要求支持至少单向遍历的迭代器。

#### **`std::accumulate`**

- **要求的迭代器类型**：前向迭代器
  - `std::accumulate` 用于计算元素的总和或某个累积值，它也只要求支持单向遍历的迭代器。

### 4. **总结**

- **随机访问迭代器**：`std::vector`, `std::deque`, `std::array`，用于要求快速随机访问的算法，如 `std::sort`, `std::lower_bound`, `std::upper_bound`。
- **双向迭代器**：`std::list`, `std::set`, `std::map`，支持双向遍历，常用于需要从两端访问元素的算法，如 `std::reverse`。
- **前向迭代器**：`std::forward_list`，支持单向遍历，用于大多数访问操作，如 `std::find`, `std::accumulate`。
- **输入输出迭代器**：`std::istream_iterator`, `std::ostream_iterator`，专用于输入和输出操作。

这些不同的容器和迭代器类型支持不同的操作，通过了解容器的迭代器要求，可以在使用标准库算法时做出最合适的选择，从而提升代码的效率和可读性。