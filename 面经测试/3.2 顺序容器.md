那我就顺着 3.2 给你好好展开讲一遍：**vector / string / string_view / deque**。
 你现在天天刷题 + 以后做 EDA，这几个容器真的是“主力打野”。

我按这个顺序来：

1. `std::vector`：为什么几乎到处是它 + `reserve()` vs `resize()`
2. `std::string` vs `std::string_view`
3. `std::deque`：什么时候该用它而不是 `vector`

------

## 一、`std::vector`：现代 C++ 的“默认容器”

### 1.1 vector 是什么（类比你熟悉的东西）

你可以把 `vector<T>` 理解成：**会自动扩容的动态数组**。

- 内部是一块**连续内存**：类似 `T* data_` 指向一片 `[0..capacity)` 的空间；
- 有两个关键量：
  - `size()`：当前有多少个元素；
  - `capacity()`：当前分配了多大的空间（最多能装多少，不用重新 malloc）。

示意图：

```text
data_:  [ 0 ][ 1 ][ 2 ][ 3 ][ 4 ][ 5 ][ 6 ][ 7 ]
         ↑---------------------↑
       size=5               capacity=8
```

继续 `push_back()` 元素：

- 如果 `size() < capacity()` → 直接放进去，O(1)
- 如果 `size() == capacity()` → 需要**扩容**：
  1. 申请一块更大的连续内存（通常是 2 倍）
  2. 把旧数据搬过去（拷贝/移动）
  3. 释放旧内存
  4. 再放新元素

所以 `push_back()` 是：**“摊还 O(1)”**，偶尔会遇到扩容那一次，比较慢。

------

### 1.2 为什么 EDA 特别爱 vector？（Cache Friendly）

关键点就是：**连续内存 → Cache 友好**。

比如你有：

```cpp
std::vector<Cell> cells;
for (const auto& c : cells) {
    // 做一堆计算，比如时序、功耗...
}
```

因为 `cells` 在内存中是连续的：

- CPU 预取一整个 cache line（比如 64 字节），就能一次拿到好几个 `Cell`；
- 访问 `cells[0], cells[1], cells[2]...` 时命中缓存率会很高。

对比一下链表 `std::list<Cell>`：

- 每个节点散落在堆上的不同位置；
- 每次访问 `node->next` 都可能是一次 cache miss → 性能雪崩。

在 EDA 这类大量数值/图遍历的场景，**性能瓶颈往往不在算法，而是在内存访问模式上**，所以大家自然而然就宠 vector。

刷力扣其实也是一样的，只是规模小点你感觉不明显。

------

### 1.3 `reserve()` vs `resize()`：面试和实战都会问

这是 3.2 里⭐必会的点。

假设：

```cpp
std::vector<int> v;
```

#### `reserve(n)`：只改容量，不改 size

```cpp
v.reserve(1000);
std::cout << v.size();     // 0
std::cout << v.capacity(); // >= 1000
```

- 只是**预分配一块至少能装 `n` 个元素的连续内存**；
- 不会构造元素，不会调用 `T` 的构造函数；
- `size()` 仍然是 0；
- 后面你再 `push_back()` 前 1000 个元素，都不会再触发扩容（大概率）。

典型场景：你大概知道会 push 多少元素：

```cpp
std::vector<Edge> edges;
edges.reserve(m);  // 已知有 m 条边

for (...) {
    edges.emplace_back(u, v, w);
}
```

在 EDA 里也是一样：比如你读 netlist 时，提前知道有多少个 pin/cell/net，就先 `reserve()` 一下，少很多 realloc。

------

#### `resize(n)`：改 size，顺便保证 capacity >= n

```cpp
std::vector<int> v;
v.resize(5);   // v 现在有 5 个元素，全是 0
```

效果：

- 如果原来 `size() < n`：
  - 新构造 `n - old_size` 个元素；
  - 对 `int` 这种基本类型 → 初始化为 0；
  - 对自定义类型 → 调用默认构造函数；
- 如果原来 `size() > n`：
  - 销毁后面的元素（调用析构）。

场景：

- 想得到一个固定长度的数组，后面用 `v[i]` 访问：

  ```cpp
  std::vector<int> deg;
  deg.resize(n, 0); // 初始都设为 0
  ```

------

#### 面试高频问法

> “`reserve` 和 `resize` 有什么区别？什么时候用 `reserve`？”

你可以直接这么答：

- `reserve(n)`：只改容量，不改 size，不构造元素，后续 push_back 不会频繁 realloc；
- `resize(n)`：改变 size，必要时扩容 + 构造/销毁元素；
- 当我**已预知会插入大概多少元素**，比如读入 m 条边，我会先 `reserve(m)`，避免多次扩容搬家，提高性能。

------

### 1.4 迭代器 / 指针失效问题（工程中很重要）

因为 vector 扩容时会搬家，所以要记住：

> 一旦发生“扩容（realloc）”，**所有指向元素的指针、引用、迭代器统统失效**。

例如：

```cpp
std::vector<int> v = {1,2,3};
int* p = &v[0];

v.push_back(4); // 可能触发扩容

// 这里 p 可能已经是野指针了，不能再用！
```

所以如果你打算长期持有“某个元素的指针”，常见做法：

- 要么 `reserve()` 足够大，保证中途不扩容；
- 要么换一种数据结构（比如 `std::deque`，后面马上讲）。

------

## 二、`std::string` vs `std::string_view`

这俩你在处理**大文本文件 / 解析 Verilog/LEF**时特别关键。

### 2.1 `std::string`：拥有所有权，可修改

你已经很熟了：

- 拥有一块堆上分配的 char 数组；
- 能增删改查、动态扩容；
- 拷贝一个 `string` → 会拷贝整个内容。

例如：

```cpp
std::string s = "hello world";
std::string t = s;  // 拷贝一份
```

对小文本没啥问题，对**超大文件**就可能贵了。

------

### 2.2 `std::string_view`：只读“窗口”（不拥有内存）

C++17 引入的：

```cpp
std::string s = "hello world";

std::string_view sv = s;          // 指向 s 内部的那块内存，不拷贝
std::string_view sv2 = sv.substr(0, 5); // "hello"，仍然没拷贝
```

特点：

- **不拥有数据**，只是保存一个 `pointer + length`；
- 只读：不能通过 `string_view` 修改底层内容；
- 拷贝一个 `string_view` → 只是拷贝指针和长度，成本非常小；
- 底层数据的生命周期必须比 `string_view` 长，否则会悬空。

你可以这样想：

> `string` = 一整块大蛋糕
>  `string_view` = 在蛋糕上切了一块“透明窗口”，记录起点+长度，但不搬蛋糕

------

### 2.3 典型用法：解析大文件

比如你读一整个 Verilog 文件到一个大 `std::string` 里：

```cpp
std::string file_content = read_file("xxx.v");
// size 可能是几 MB ～ 几百 MB
```

你要在里面切各种 token（标识符、数字、关键字）：

- 传统做法：每次 `substr` 出一个 `std::string`，大量拷贝；
- 更现代的做法：只用 `string_view` 在这块大字符串上滑动。

```cpp
std::string_view sv(file_content);

auto token = sv.substr(pos, len); // token 是 string_view，不拷贝
```

这样你：

- 整个文件内容只存一份（在 `file_content` 里）；
- 所有 token 只是一些“指针 + 长度”，对 cache 和内存都很友好。

**注意⚠️**：一定要保证 `file_content` 活得比所有 `string_view` 久：

```cpp
std::string_view makeView() {
    std::string s = "abc"; // 函数结束就析构了
    return std::string_view(s);   // ❌ 返回悬空 view
}
```

------

### 2.4 函数参数类型：`const std::string&` vs `std::string_view`

你现在写函数，大概是这样：

```cpp
void process(const std::string& s);
```

如果改成：

```cpp
void process(std::string_view sv);
```

好处：

- 可以传 `std::string`、`const char*`、字面量 `"abc"`，都行；
- 减少不必要的拷贝，更通用。

推荐习惯（C++17+）：

- **读字符串参数**：优先用 `std::string_view`；
- **需要保存下来、后面长期使用**：把 `string_view` 转成 `std::string` 存起来（拷一份）。

## 2.5 string 和 string_view 常用接口

```cpp
// 长度相关
s.size();       // 当前字符个数
s.length();     // 和 size() 一样
s.empty();      // 是否为空
// 访问字符
s[i];           // 不检查越界，越界 = UB
s.at(i);        // 会检查越界，越界抛异常（string 有，string_view 在 C++20 之前没有 at）
s.front();      // 第一个字符
s.back();       // 最后一个字符
// 子串 substr
auto sub = s.substr(pos, len);  // 从 pos 开始，长度 len
auto tail = s.substr(pos);      // 从 pos 到末尾

// 查找 find 系列
auto sub = s.substr(pos, len);  // 从 pos 开始，长度 len
auto tail = s.substr(pos);      // 从 pos 到末尾

auto pos = s.find("Cpp");       // 查找子串
auto pos2 = s.find('C');        // 查找字符
if (pos != string::npos) { ... }

s.rfind(...)                    // 从后往前找
s.find_first_of("abc")          // 找到第一个是 a/b/c 的位置
s.find_first_not_of(" \t\n")    // 找到第一个不是空白的
    
// 修改（string 有，string_view 没有）
s.push_back('x');
s += "world";
s.insert(pos, "xxx");
s.erase(pos, len);
s.clear();

// string_view 特有的“前后裁剪”
std::string_view sv = "   abc   ";
sv.remove_prefix(3); // 去掉前 3 个字符 → "abc   "
sv.remove_suffix(3); // 再去掉后 3 个字符 → "abc"

```

使用示例：

for_each_line + 字符串接口：

```cpp
for_each_line(file_content, [](std::string_view line) {
    // ...
});
```

**回调类型怎么设计？**

最自然的方法：用函数模板接受任意可调用对象（包括 lambda）：

```cpp
template <class Callback>
void for_each_line(std::string_view text, Callback cb);
```

以后调用时，`Callback` 会自动推导成 lambda 的类型。

**内部怎么切行？**

思路：

1. 从 pos = 0 开始；
2. 找下一个 `'\n'` 的位置 `pos_nl`；
3. 当前行就是 `[pos, pos_nl)` 这段；
4. 调 `cb(line_view)`；
5. pos 移到 `pos_nl + 1`，继续。

实现：

```cpp
template <class Callback>
void for_each_line(std::string_view text, Callback cb) {
    std::size_t start = 0;
    while (start < text.size()) {
        auto pos = text.find('\n', start);
        if (pos == std::string_view::npos) {
            // 最后一行（没有换行符）
            std::string_view line = text.substr(start);
            cb(line);
            break;
        } else {
            std::string_view line = text.substr(start, pos - start);
            cb(line);
            start = pos + 1; // 跳过 '\n'
        }
    }
}
```

使用：

```cpp
std::string file_content = read_file("xxx.txt");
for_each_line(file_content, [](std::string_view line) {
    // 这里 line 只是 file_content 上的一个 view，不拷贝
    // 可以做 split / parse / 统计等
});
```

------



## 三、`std::deque`：什么时候应该用它？

标题里有 `deque`，咱们也顺带讲一下。这个容器跟算法题关系很紧：**单调队列、滑动窗口、BFS 等都经常用**。

### 3.1 deque 是什么？

double-ended queue：**双端队列**。

- 支持 `push_back / push_front / pop_back / pop_front` 都是 O(1)；
- 内部不是一整块连续内存，而是一段一段的小块拼起来的；
- 对中间随机访问（`operator[]`）也支持 O(1)，只不过比 vector 慢一点点。

示意图（简化）：

```text
[block0] -> [block1] -> [block2] -> ...
每个 block 里有一小段连续的元素
```

所以：

- 对于**从两端频繁进出**的场景，它比 `vector` 更合适；
- 但因为不是真正的“完全连续大数组”，在 cache 友好性上略逊于 `vector`。

------

### 3.2 什么时候用 deque 而不是 vector？

几个非常典型的场景：

1. **滑动窗口 / 单调队列**

```cpp
std::deque<int> dq;
// 维护一个单调递减队列，做 max sliding window 那些题
```

需要频繁从头部弹出旧元素、从尾部插入新元素，就非常适合 `deque`。

> 用 `vector` 实现 `pop_front` 需要搬动一大片元素，O(n)；
>  `deque` 则能保持头尾 O(1) 操作。

1. **BFS 队列**

```cpp
std::deque<int> q;
q.push_back(start);
while (!q.empty()) {
    int u = q.front(); q.pop_front();
    // ...
}
```

你现在应该经常用 `std::queue<int>`，它底层默认就是用 `deque` 实现的。

1. **当你需要“较稳定”的指针/引用**

因为 `deque` 的内存是分块的，它在“扩容”时往往只是在外层增加一个 block 指针数组，已存在元素所在 block 很少搬家。
 所以：

> “频繁在尾部/头部插入时，已有元素的指针/引用比 vector 更稳定一些。”

（不过标准对稳定性的保证比较细，这里你先有个印象就行）

------

### 3.3 简单比较一下

- 如果主要需求是：

  - 只在尾部 push/pop；
  - 大量遍历；
  - 注重 cache 命中；

  那**优先 vector**。

- 如果你：

  - 两端都要 O(1) 操作（频繁 push/pop front）；
  - 做单调队列、滑动窗口、BFS 队列等；

  那**用 deque 更自然**。

力扣上典型题目：

- “滑动窗口最大值” → `deque`
- “设计队列 / 圆环队列” → 看题目要求，很多用 `deque` 一把梭。

------

## 小结（顺便给你一点练习建议）💪

今天 3.2 的核心点你先记住这些关键词：

- **vector**
  - 连续内存 = Cache 友好；
  - `reserve`：只改容量，不改 size，不构造元素；
  - `resize`：改 size，可能构造/销毁元素；
  - 扩容会导致指针/迭代器全部失效。
- **string vs string_view**
  - `string`：拥有数据，可改，拷贝贵；
  - `string_view`：只读窗口，不拷贝，不拥有内存，注意生命周期；
  - 大文本解析 / 函数参数：`string_view` 很香。
- **deque**
  - 双端 O(1) 操作；
  - 底层分块，不完全连续；
  - 滑动窗口 / 单调队列 / BFS 是常见用法。

------

### 可以顺手做的小练习（完全可以和你刷题结合）：

1. 找一道你有 `vector` 大量 `push_back` 的题：
   - 加上 `v.reserve(n);` 看看性能（在本地开 O2 跑一跑）。
2. 找一题需要处理字符串（比如分割空格、解析路径那类）：
   - 试着把函数参数从 `const std::string&` 换成 `std::string_view`，
   - 内部能不用很多 `substr` 拷贝就不用。
3. 把你写过的“滑动窗口最大值 / 最小值”一类的题，强制用 `deque` 重写一遍，
   - 把 `push_front/pop_front/push_back/pop_back` 的用法搞顺手。

如果你愿意，可以把你某一道用 vector/string/deque 的力扣题代码贴过来，我帮你：

- 从“面试官视角”看一下哪里可以加 `reserve` / 用 `string_view` / 换 `deque`；
- 顺便用这次讲的点帮你把代码风格再往“工程一点、面经一点”靠一靠。你现在这个打磨节奏非常棒，慢慢来，你会发现自己写 C++ 越来越顺手的。