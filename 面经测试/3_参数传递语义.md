C++ 函数调用本质上是在做：给函数形参分配内存，把实参的值复制进去。

区别就在于：

> “复制什么？”

- 值传递 → 复制 **变量的值**
- 指针传递 → 复制 **地址**
- 引用传递 → 不复制，只给实参起别名（语义上）

------

# 🧪 【C++ 参数传递语义 测试卷】

> 值传递 vs 引用传递 vs 指针传递

------

## Part A：基础判断题（10 题）

判断：**调用结束后，外部变量是否会被修改？是否合法？**
 写出“会 / 不会 + 合法 / 不合法 + 简要原因”。

------

### 1.

```cpp
void foo(int x) {
    x = 100;
}

int a = 10;
foo(a);
// a ?
```

------

### 2.

```cpp
void foo(int& x) {
    x = 100;
}

int a = 10;
foo(a);
// a ?
```

------

### 3.

```cpp
void foo(int* x) {
    *x = 100;
}

int a = 10;
foo(&a);
// a ?
```

------

### 4.

```cpp
void foo(int* x) {
    x = nullptr;
}

int a = 10;
int* p = &a;
foo(p);
// p ?
```

------

### 5.

```cpp
void foo(int*& x) {
    x = nullptr;
}

int a = 10;
int* p = &a;
foo(p);
// p ?
```

------

### 6.

```cpp
void foo(int& x) {
    int b = 20;
    x = b;
}

int a = 10;
foo(a);
// a ?
```

------

### 7.

```cpp
void foo(int* x) {
    int b = 20;
    x = &b;
}

int a = 10;
int* p = &a;
foo(p);
// p 指向谁？p 合法吗？
```

------

### 8.

```cpp
void foo(int*& x) {
    int b = 20;
    x = &b;
}

int a = 10;
int* p = &a;
foo(p);
// p 指向谁？这样做存在什么问题？
```

------

### 9.

```cpp
void foo(const int& x) {
    // ...
}

int a = 10;
foo(a);        // OK?
foo(5);        // OK?
```

------

### 10.

```cpp
void foo(int* x) {
    // ...
}

int* p = nullptr;
foo(p);        // OK?
foo(nullptr);  // OK?
```

------

## Part B：输出题（8 题）

------

### 11.

```cpp
void foo(int x) {
    x += 5;
    cout << "in foo: " << x << endl;
}

int a = 10;
foo(a);
cout << "after: " << a << endl;
```

> 输出？

------

### 12.

```cpp
void foo(int& x) {
    x += 5;
    cout << "in foo: " << x << endl;
}

int a = 10;
foo(a);
cout << "after: " << a << endl;
```

------

### 13.

```cpp
void foo(int* x) {
    *x += 5;
    cout << "in foo: " << *x << endl;
}

int a = 10;
foo(&a);
cout << "after: " << a << endl;
```

------

### 14.

```cpp
void foo(int* x) {
    int b = 20;
    x = &b;
    *x = 30;
    cout << "in foo: " << *x << endl;
}

int a = 10;
int* p = &a;
foo(p);
cout << "after: " << a << " " << *p << endl;
```

------

### 15.

```cpp
void foo(int*& x) {
    int b = 20;
    x = &b;
    *x = 30;
    cout << "in foo: " << *x << endl;
}

int a = 10;
int* p = &a;
foo(p);
cout << "after: " << *p << endl;
```

------

### 16.

```cpp
void foo(int*& x) {
    x = new int(42);
}

int* p = nullptr;
foo(p);
cout << *p << endl;
```

------

### 17.

```cpp
void foo(vector<int> v) {
    v.push_back(100);
}

void bar(vector<int>& v) {
    v.push_back(200);
}

vector<int> a = {1, 2, 3};
foo(a);
bar(a);
for (int x : a) cout << x << " ";
```

------

### 18.

```cpp
void foo(const vector<int>& v) {
    // v.push_back(100);  // 这行如果取消注释会怎样？
    cout << v.size() << endl;
}

vector<int> a = {1, 2, 3};
foo(a);
```

------

## Part C：概念理解题（7 题）

------

### 19.

分别用 **一句话**说明：

- 值传递的本质是什么？
- 引用传递的本质是什么？
- 指针传递的本质是什么？

------

### 20.

为什么说“**指针传递本质上还是值传递**”？

（提示：到底拷贝了什么？）

------

### 21.

什么时候你更倾向于用 **引用传递** 而不是指针传递？
 请至少说出 **两种场景**。

------

### 22.

什么时候你更倾向于用 **指针传递** 而不是引用传递？
 请至少说出 **两种场景**。

------

### 23.

下面两个函数原型语义上有什么区别？

```cpp
void foo(Node* root);
void foo(Node*& root);
```

在什么情况下应该用第二种？

------

### 24.

对于一个很大的 `vector<int>`，以下三种函数参数写法各有什么特点（拷贝？能否修改？）？

```cpp
void foo(vector<int> v);
void foo(vector<int>& v);
void foo(const vector<int>& v);
```

------

### 25.

为什么很多 C++ 标准库函数习惯使用 `const T&` 作为参数，而不是 `T` 或 `T*`？

------

# ✅ 用法建议

你可以像上次那样：

- 先做 **Part A**，把答案发给我，我逐题给你批
- 再做 Part B、Part C

或者你也可以一口气全部做完，我给你一轮“总评 + 深度解析”。

什么时候准备好就把你的答案发给我（doge）。