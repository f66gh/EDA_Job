1. Timing Path这个是用的deque吗，因为拓扑排序BFS的话会用到队列；net查找用umap，因为无序，操作频繁；slack用map，因为涉及到键值对和顺序访问
2. size是已经分配的内存，capacity是当前的容量。reserve是预留空间，resize是分配并写入空间，多了删除，少了补充，shrink_to_fit是把容量缩减为size吗？当vector尾部push_back时，如果空间不够会扩容，若检测到当前连续地址不够扩容的，则会给vector realloc一个地方足够的地址。这部分设计到拷贝，所以很慢。
3. map的平均和最坏全是O(logn)，umap的平均是O(1)，最坏是O(n)。map时按照key值遍历的，umap是key的哈希值遍历的。map支持lower_bound和upper_bound因为有序，而umap没有
4. sort要求随机访问迭代器，list不能顺序访问只能顺序访问（能再列举容器哪些是双向哪些是单项哪些是随机的吗）。reverse要求至少双向迭代器，lower_bound双向迭代器？vector是随机访问器，list是双向迭代器，map和umap忘记了
5. 说不出来`std::vector<Node>`和`std::vector<Node*>`应用场景的区别。
6. 因为明确向函数开发者和调用者这个函数是只读或可修改函数。n1（Graph&）可以修改，n2(const Graph&)不可修改。
7. 

```cpp
void foo1(Path p); // 有拷贝，修改形参对实参没影响，用途广泛
void foo2(const Path& p); // 无拷贝，形参和实参不可变，仅读
void foo3(Path& p); // 无拷贝，修改形参就是修改实参，修改调用者对象
void foo4(Path&& p); // 右值引用，延长右值的生命周期（右值引用的底层是什么来着，std::move是啥意思来着）
```

我选foo2和foo4。foo2不修改源对象，foo4是传入要死亡的对象。
