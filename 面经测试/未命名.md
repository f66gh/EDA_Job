1. 不知道`v.size()` 和 `v.capacity()` 各是多少（size应该是0）；reserve是告诉编译器vector至少有多大，在size没有超过这个数的时候不改变size，不调用构造和析构，可能触发内存搬迁（要搬到一个能装的下reserve传入大小的连续地址），resize改变size为自己传进去的值，会调用析构和构造，要是连续内存不够可能触发内存搬迁。优化了vector不会频繁realloc的问题。
2. A行：一定发生扩容，以为这时候的vector大小就2，已经填满了。p和r不一定失效，可能是紧接着在原地扩容的，没有realloc。
   B行：不扩容了，因为此时的size是3，分配的size 是4
3. string拥有底层内存，string_view没有，当需要拷贝变字符串的时候需要用到string，当不需要拷贝读的需求时用到string_view。
   这个函数并不安全，这里返回的是s的地址，而s的地址在函数结束后已经被回收，造成UB。（如果我把string_view换成string也会造成悬空指针吗）
   这个函数在big没被回收的条件下都是安全的。
4. A: size=0 cap=5；B：1 2 3；C: size = 3 cap = 10; D: 1 （vector<int> vec(n, 0)这个初始化定义数组大小和初始化值和resize是一回事吗）
5. s = EDA\_-pp_Interview；sv1 = EDA\_-pp_Interview; sv2 = -pp sv3 =Interview。因为string_view只存字符串的地址和偏移量。
6. size=2  3 4     这个容器每被遍历到一个可以被2整除的值就从队列头部弹出一个值，尽管atuo x能正确遍历，我也不知道有什么严重问题，就是很奇怪。
7. 不知道为什么是未定义。，
8. 这个函数想找到传入字符串中的"_"然后返回“\_”之后的字符串（不是真的返回字符串）。sv不安全，因为s在函数结束之后就被释放了，还是返回这个地址，造成未定义行为。

```cpp
#include <string>
#include <string_view>
using namespace std;

string_view get_suffix(const char* text) {
    auto pos = text.find('_');
    if (pos == string::npos) return string_view{};
    return string_view(text).substr(pos + 1);
}
```

9. 略过，这个我在上一套你出的题写过类似的满分答案
10. 

```cpp
struct Command {
    std::string_view cmd;
    std::string_view arg1;
    std::string_view arg2;
};

Command parse_command(std::string_view line){
    return {
        string_view(line).substr(0, 3);
        string_view(line).substr(5, 3);
        string_view(line).substr(8, 3);
    }
};
```

11. 这是我第三遍做这个题了，前两遍在力扣做的

```cpp
std::vector<int> max_in_window(const std::vector<int>& nums, int k){
    std::deque<int> dq;
    std::vector<int> vec;
    for(int i = 0; i < nums.size(); i++){
        while(!dq.empty() && nums[dq.back()] < nums[i]) dq.pop_back();
        dq.push_back(i);
        if(dq.size() > k) dq.pop_front();
        if(i >= k - 1 && !dq.empty()) vec.push_back(dq.front());
    }
    return vec;
};
```

12. 不会了，你再给我讲讲字符串常用的接口呗

```cpp
void for_each_line(file_content, [](std::string_view line) {
    
});

```

