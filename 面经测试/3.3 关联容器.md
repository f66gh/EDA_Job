å¥½ï¼Œ3.3 åˆ°äº†â€œçœŸæ­£å†™é¢˜ + å†™å·¥ç¨‹â€é‡Œæœ€å¸¸ç”¨çš„ä¸€å—ï¼š**map / unordered_map**ã€‚
 æˆ‘æŒ‰ä½ ä»¥åå†™åŠ›æ‰£ + EDA çš„ä½¿ç”¨åœºæ™¯ï¼Œç»™ä½ ç³»ç»Ÿè®²ä¸€éï¼Œé¡ºå¸¦æŠŠå‰é¢ `auto / èŒƒå›´ for / lambda / struct` éƒ½ä¸²è¿›æ¥ã€‚

------

## ä¸€ã€å…ˆææ¸…æ¥šï¼šä»€ä¹ˆæ˜¯â€œå…³è”å®¹å™¨â€

å‰é¢çš„ `vector / string / deque` è¿™äº›ï¼Œæ˜¯**é¡ºåºå®¹å™¨**ï¼š

- å…ƒç´ æ’åœ¨ä¸€æ¡çº¿é‡Œï¼ŒæŒ‰ä¸‹æ ‡è®¿é—®ï¼š`v[i]`
- å…ƒç´ çš„ä½ç½®å’Œæ’å…¥é¡ºåºã€ä¸‹æ ‡æœ‰å…³

**å…³è”å®¹å™¨**ï¼šæ ¸å¿ƒæ€æƒ³æ˜¯â€”â€”**ç”¨ Key æ‰¾ Value**ï¼š

```cpp
mp["clk"]    -> æŒ‡å‘æŸä¸ª Node*
mp["U1234"]  -> æŸä¸ª cell
mp[42]       -> æŸä¸ªå€¼ï¼ˆé¢‘æ¬¡ã€çŠ¶æ€...ï¼‰
```

ä½ å¯ä»¥æŠŠ `map / unordered_map` éƒ½ç†è§£æˆï¼š

> **Key â†’ Value çš„æ˜ å°„è¡¨**

åŒºåˆ«åªåœ¨äºï¼š**å†…éƒ¨æ˜¯æ€ä¹ˆå­˜**ã€**æŸ¥æ‰¾å¤æ‚åº¦**ã€**æ˜¯å¦æœ‰åº**ã€‚

------

## äºŒã€`std::unordered_map`ï¼šé»˜è®¤ç”¨å®ƒå°±å¯¹äº†

> é¢ç»é‡Œå†™äº†ï¼š
>
> - åº•å±‚å“ˆå¸Œè¡¨ï¼ŒæŸ¥æ‰¾å‡æ‘Š O(1)
> - å¸¸ç”¨äº `NameString -> Node*` è¿™ç§æ˜ å°„

### 2.1 å®ƒçš„ç‰¹ç‚¹

- åº•å±‚æ˜¯**å“ˆå¸Œè¡¨**ï¼ˆhash tableï¼‰ï¼›
- é€šè¿‡ `hash(key)` ç®— Key çš„å“ˆå¸Œå€¼ï¼Œè½åˆ°æŸä¸ª bucket é‡Œï¼›
- **å¹³å‡å¤æ‚åº¦ï¼š**
  - æ’å…¥ï¼šO(1)
  - æŸ¥æ‰¾ï¼šO(1)
  - åˆ é™¤ï¼šO(1)
- **Key æ— åº**ï¼šéå†æ—¶é¡ºåºæ˜¯â€œå“ˆå¸Œæ¡¶é¡ºåºâ€ï¼Œè·Ÿæ’å…¥é¡ºåº/å¤§å°é¡ºåºéƒ½æ— å…³ã€‚

ä½ å¹³æ—¶åœ¨åŠ›æ‰£é‡Œå†™ï¼š

```cpp
std::unordered_map<int, int> cnt;
for (int x : nums) {
    cnt[x]++;  // ç»Ÿè®¡é¢‘æ¬¡
}
```

è¿™å°±æ˜¯æœ€å…¸å‹çš„å¥—è·¯ã€‚

EDA é‡Œä¾‹å­ï¼š

```cpp
std::unordered_map<std::string, Node*> name2node;
name2node["clk"] = clk_node;
name2node["reset"] = rst_node;
```

------

### 2.2 å¸¸ç”¨æ¥å£ï¼ˆé…åˆ 3.1 é‚£äº›è¯­æ³•ï¼‰

å‡è®¾ï¼š

```cpp
std::unordered_map<std::string, int> mp;
```

**æ’å…¥ / è®¿é—®ï¼š**

```cpp
mp["A"] = 1;   // å¦‚æœæ²¡æœ‰ "A"ï¼Œä¼šæ’å…¥é»˜è®¤å€¼ 0 å†èµ‹å€¼ä¸º 1
mp["B"] += 10; // ä¸å­˜åœ¨å°±å…ˆæ’å…¥ 0ï¼Œå† +10
```

**åªæŸ¥ä¸æ”¹ï¼ˆé¿å…æ— æ„æ’å…¥ï¼‰ï¼š**

```cpp
auto it = mp.find("C");
if (it != mp.end()) {
    std::cout << it->first << " " << it->second;
}
```

**éå†ï¼š**

```cpp
for (const auto& [key, value] : mp) {  // C++17 ç»“æ„åŒ–ç»‘å®š
    std::cout << key << " -> " << value << "\n";
}
```

å¦‚æœä¸ç”¨ç»“æ„åŒ–ç»‘å®šï¼š

```cpp
for (const auto& kv : mp) {
    const auto& key = kv.first;
    const auto& value = kv.second;
}
```

------

### 2.3 å†æé†’ä¸€ä¸ªå‘ï¼š`operator[]` ä¼šâ€œé¡ºæ‰‹æ’å…¥â€

```cpp
std::unordered_map<std::string, int> mp;
int x = mp["not_exist"];  // ä¼šæ’å…¥ key="not_exist", value=0
```

æ‰€ä»¥ï¼š

- **åªæƒ³æŸ¥æœ‰æ²¡æœ‰** â†’ ç”¨ `find`ï¼›
- **æƒ³ç”¨â€œæ²¡æœ‰å°±æ’å…¥ 0â€è¿™ç§è¡Œä¸º** â†’ å†ç”¨ `operator[]`ã€‚

------

### 2.4 æ‰©å±•ä¸€ç‚¹ï¼šå“ˆå¸Œè¡¨ rehash & è¿­ä»£å™¨å¤±æ•ˆ

åº•å±‚æœ‰å¾ˆå¤š bucketï¼Œå½“å…ƒç´ å¤šäº†ã€è£…ä¸ä¸‹ï¼Œå°±ä¼šï¼š

1. åˆ†é…æ›´å¤š bucketï¼›
2. æŠŠæ‰€æœ‰å…ƒç´ é‡æ–°åˆ†é…åˆ°æ–° bucketï¼ˆrehashï¼‰ã€‚

è¿™æ—¶å€™ï¼š

> `unordered_map` çš„ **æ‰€æœ‰è¿­ä»£å™¨ / æŒ‡é’ˆ / å¼•ç”¨éƒ½æœ‰å¯èƒ½å¤±æ•ˆ**ï¼ˆå®ç°è§„å®šçš„é‚£ç§ï¼‰ã€‚

æ‰€ä»¥è·Ÿ `vector` å¾ˆåƒï¼š
 **åœ¨æ’å…¥å¾ˆå¤šå…ƒç´ ï¼ˆç‰¹åˆ«æ˜¯è¶…å‡º `reserve` æˆ– load factorï¼‰æ—¶ï¼Œä¸è¦é•¿æœŸæ‹¿ç€è¿­ä»£å™¨/æŒ‡é’ˆã€‚**

**å’Œ vectorã€map å¯¹æ¯”ï¼ˆé‡ç‚¹è®°è¿™ä¸ªè¡¨ï¼‰**

- `std::vector`
  - `push_back` è§¦å‘æ‰©å®¹ âœ æ‰€æœ‰è¿­ä»£å™¨ / å¼•ç”¨ / æŒ‡é’ˆå…¨éƒ¨å¤±æ•ˆ
  - `erase(pos)` âœ `pos` ä»¥åŠä¹‹åçš„è¿­ä»£å™¨éƒ½å¤±æ•ˆ
- `std::map`
  - æ’å…¥ï¼š**ä¸ä¼š**ä½¿ç°æœ‰è¿­ä»£å™¨å¤±æ•ˆ
  - `erase(it)`ï¼šåªè®©æŒ‡å‘è¢«åˆ èŠ‚ç‚¹çš„è¿­ä»£å™¨å¤±æ•ˆï¼Œå…¶ä»–è¿­ä»£å™¨ä»ç„¶æœ‰æ•ˆ
- `std::unordered_map`
  - æ™®é€šæ’å…¥ï¼Œè‹¥æ—  rehashï¼šè¿­ä»£å™¨ä¸€èˆ¬ä»æœ‰æ•ˆ
  - è‹¥ rehashï¼šæ‰€æœ‰è¿­ä»£å™¨å¤±æ•ˆ
  - `erase(it)`ï¼šåªè®©æŒ‡å‘è¢«åˆ å…ƒç´ çš„è¿­ä»£å™¨å¤±æ•ˆ

------

## ä¸‰ã€`std::map`ï¼šæœ‰åºçš„ Key â†’ Value æ˜ å°„

> é¢ç»é‡Œå†™ï¼š
>
> - åº•å±‚çº¢é»‘æ ‘ï¼ŒKey æœ‰åº

### 3.1 ç‰¹ç‚¹

- åº•å±‚æ˜¯ **å¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼ˆçº¢é»‘æ ‘ï¼‰**ï¼›
- æ‰€æœ‰ Key æŒ‰ `<` æ’å¥½åºï¼›
- **å¤æ‚åº¦ï¼ˆå¯¹ n ä¸ªå…ƒç´ ï¼‰ï¼š**
  - æ’å…¥ï¼šO(log n)
  - æŸ¥æ‰¾ï¼šO(log n)
  - åˆ é™¤ï¼šO(log n)
- éå†æ—¶ï¼š**æŒ‰ Key ä»å°åˆ°å¤§**

ä¾‹å¦‚ï¼š

```cpp
std::map<int, std::string> mp;
mp[10] = "ten";
mp[3]  = "three";
mp[7]  = "seven";

for (const auto& [k, v] : mp) {
    std::cout << k << " ";   // è¾“å‡ºï¼š3 7 10
}
```

### 3.2 ä»€ä¹ˆæ—¶å€™ç”¨ `map` è€Œä¸æ˜¯ `unordered_map`ï¼Ÿ

**ç”¨ map çš„å…¸å‹åœºæ™¯ï¼š**

1. ä½ éœ€è¦**æŒ‰ Key æœ‰åºéå†**ï¼ˆæ¯”å¦‚è¾“å‡ºæŒ‰åå­—æ’åºã€æŒ‰åæ ‡æ’åºï¼‰ï¼›

2. ä½ éœ€è¦ç”¨ `lower_bound` / `upper_bound` ä¹‹ç±»çš„**èŒƒå›´æŸ¥è¯¢**ï¼š

   ```cpp
   auto it = mp.lower_bound(10); // ç¬¬ä¸€ä¸ª key >= 10 çš„ä½ç½®
   ```

3. ç¯å¢ƒå¾ˆæç«¯ï¼Œä¸å…è®¸å“ˆå¸Œè¡¨çš„æœ€å O(n)ï¼ˆä¸€èˆ¬é¢è¯•/åˆ·é¢˜ä¸ç”¨è¿™ä¹ˆæç«¯è€ƒè™‘ï¼‰ã€‚

**ç”¨ unordered_map çš„å…¸å‹åœºæ™¯ï¼š**

- åªå…³å¿ƒ â€œç»™æˆ‘è¿™ä¸ª Key çš„ Valueâ€ï¼›
- ä¸åœ¨ä¹éå†é¡ºåºï¼›
- è¿½æ±‚æŸ¥æ‰¾ O(1) å¸¸æ•°å°ã€‚

ä½ å¯ä»¥è®°ä¸€ä¸ªç®€å•çš„å†³ç­–ï¼š

> **é»˜è®¤ unordered_mapï¼Œé™¤éä½ çœŸçš„éœ€è¦ Key æ˜¯æœ‰åºçš„ï¼Œè¿™æ—¶ç”¨ mapã€‚**

------

## å››ã€è‡ªå®šä¹‰ Keyï¼šç»“æ„ä½“å½“ Key æ€ä¹ˆåŠï¼Ÿ

é¢ç»é‡Œä¸“é—¨æäº†è¿™ä¸€å¥ï¼š

> è‡ªå®šä¹‰ Keyï¼š
>
> - ç”¨ç»“æ„ä½“å½“ Keyï¼Œ`map` éœ€è¦é‡è½½ `<`
> - `unordered_map` éœ€è¦å†™ `hash` å‡½æ•°

æˆ‘ä»¬æ¥å„è®²ä¸€ä¾‹å­ã€‚

------

### 4.1 `map` + struct Keyï¼šé‡è½½ `<`

å‡è®¾ä½ è¦ç”¨äºŒç»´åæ ‡å½“ Keyï¼š

```cpp
struct Point {
    int x;
    int y;
};
```

æƒ³è¦ï¼š

```cpp
std::map<Point, double> delay;
```

é‚£ä½ å¿…é¡»å‘Šè¯‰ `map`ï¼Œä¸¤ä¸ª `Point` æ€ä¹ˆâ€œæ¯”è¾ƒå¤§å°â€ã€‚
 æœ€å¸¸è§çš„åšæ³•ï¼šåœ¨ `Point` é‡Œé‡è½½ `<`ï¼ˆå­—å…¸åºï¼‰ï¼š

```cpp
struct Point {
    int x;
    int y;

    bool operator<(const Point& other) const {
        if (x != other.x) return x < other.x;
        return y < other.y;
    }
};
```

è¿™å°±å®šä¹‰äº†ä¸€ä¸ªä¸¥æ ¼å¼±åºï¼ˆé¢è¯•å®˜ä½ å¯ä»¥ç›´æ¥è¯´â€œå­—å…¸åºæ’åºâ€ï¼‰ã€‚

ä»¥åè¿™ä¸ª `map` çš„ Key é¡ºåºå°±æ˜¯æŒ‰ `(x, y)` ä»å°åˆ°å¤§ã€‚

------

### 4.2 `unordered_map` + struct Keyï¼šè‡ªå®šä¹‰ hash + equal

åŒæ ·çš„ `Point`ï¼Œå¦‚æœä½ è¦ï¼š

```cpp
std::unordered_map<Point, double, PointHash> mp;
```

éœ€è¦ä¸‰ä¸ªä¿¡æ¯ï¼š

1. ä¸€ä¸ª `Point` ç±»å‹ï¼›
2. ä¸€ä¸ªå“ˆå¸Œå‡½æ•°ï¼š`std::size_t operator()(const Point&)`ï¼›
3. ä¸€ä¸ªç›¸ç­‰åˆ¤æ–­ï¼ˆç”¨ `==` æˆ–è‡ªå®šä¹‰ `KeyEqual`ï¼‰ï¼Œä¿è¯ç›¸ç­‰çš„ Key å“ˆå¸Œå€¼ç›¸åŒã€‚

ç®€å•åšæ³•ï¼š

```cpp
struct Point {
    int x;
    int y;

    bool operator==(const Point& other) const {
        return x == other.x && y == other.y;
    }
};

struct PointHash {
    std::size_t operator()(const Point& p) const noexcept {
        // ç®€å•åˆå¹¶ï¼šæŠŠ x, y æ··åˆä¸€ä¸‹
        return std::hash<int>()(p.x) ^ (std::hash<int>()(p.y) << 1);
    }
};

std::unordered_map<Point, double, PointHash> mp;
```

ä¸€èˆ¬é¢è¯•çš„æ—¶å€™ï¼Œä½ è¯´ï¼š

> â€œunordered_map éœ€è¦ä¸€ä¸ª hashï¼Œå®ƒè¦æ±‚ç›¸ç­‰çš„ key å¿…é¡» hash ç›¸åŒï¼Œæ‰€ä»¥æˆ‘å®šä¹‰ `operator==` ä½œä¸ºç›¸ç­‰åˆ¤å®šï¼Œå†ç”¨ std::hash æ··åˆ x, yã€‚â€

å°±å¾ˆåˆæ ¼äº†ã€‚

------

## äº”ã€å’Œä¹‹å‰ç« èŠ‚çš„â€œè”åŠ¨â€

æ¥ä¸²ä¸€ä¸‹ä½ å·²ç»å­¦çš„ä¸œè¥¿ï¼Œé¡ºä¾¿ç»™å‡ ä¸ªâ€œé¢è¯•å‹å¥½å†™æ³•â€ã€‚

### 5.1 èŒƒå›´ for + auto + ç»“æ„åŒ–ç»‘å®šéå† map / unordered_map

```cpp
std::unordered_map<std::string, int> mp = {
    {"A", 1},
    {"B", 2},
    {"C", 3}
};

// åªè¯»éå†
for (const auto& [key, value] : mp) {
    std::cout << key << " -> " << value << "\n";
}

// ä¿®æ”¹ value
for (auto& [key, value] : mp) {
    value += 10;
}
```

å¯¹ä½ è¿™ç§å¤©å¤©å†™é¢˜çš„äººæ¥è¯´ï¼Œè¿™ç§å†™æ³•å¾ˆè‡ªç„¶ï¼›
 é¢è¯•é‡Œå†™å‡ºæ¥ï¼Œä¹Ÿèƒ½é¡ºä¾¿å±•ç¤ºä½ ä¼š C++17 çš„ç»“æ„åŒ–ç»‘å®šã€‚

------

### 5.2 lambda + mapï¼šè‡ªå®šä¹‰æ’åºéå†ç»“æœ

æ¯”å¦‚ä½ æœ‰ä¸€ä¸ª `unordered_map<std::string,int>` ç»Ÿè®¡é¢‘æ¬¡ï¼Œæƒ³æŒ‰é¢‘æ¬¡ä»å¤§åˆ°å°è¾“å‡ºã€‚

```cpp
std::unordered_map<std::string, int> mp;
// ... å·²ç»å¡«å¥½

std::vector<std::pair<std::string, int>> vec(mp.begin(), mp.end());

std::sort(vec.begin(), vec.end(),
          [](const auto& a, const auto& b) {
              return a.second > b.second;  // é™åº
          });

for (const auto& [key, value] : vec) {
    std::cout << key << ": " << value << "\n";
}
```

è¿™é‡Œå°±æŠŠï¼š

- `unordered_map` çš„ O(1) æŸ¥æ‰¾ï¼›
- `vector` çš„æ’åºï¼›
- `lambda` è‡ªå®šä¹‰æ’åºï¼›
- `auto` / ç»“æ„åŒ–ç»‘å®š

å…¨ä¸²èµ·æ¥äº†ã€‚

------

### 5.3 `string_view` + `unordered_map`ï¼ˆè¿›é˜¶ä¸€ç‚¹ç‚¹ï¼Œå…ˆæœ‰æ¦‚å¿µï¼‰

æœ‰çš„è§£æå™¨ä¼šç”¨ï¼š

```cpp
std::unordered_map<std::string_view, Node*> name2node;
```

å¥½å¤„æ˜¯ï¼š

- ä¸æ‹·è´å­—ç¬¦ä¸²ï¼Œåªç”¨ view æŒ‡å‘åŸæ¥çš„å¤§æ–‡æœ¬ï¼›
- ä½†è¦éå¸¸å°å¿ƒï¼šæ‰€æœ‰ key å¯¹åº”çš„å­—ç¬¦ä¸²**å¿…é¡»åœ¨ map ç”Ÿå‘½å‘¨æœŸå†…ä¸€ç›´æœ‰æ•ˆ**ï¼ˆä¸èƒ½æŒ‡å‘å·²ç»é‡Šæ”¾çš„ `string`ï¼‰ã€‚

è¿™å—æœ‰ç‚¹è¿›é˜¶ï¼Œä½ ç°åœ¨çŸ¥é“æœ‰è¿™ä¹ˆä¸ªç©æ³•å°±å¥½ï¼Œä»¥åå†™è§£æå™¨ä¼šé‡åˆ°ã€‚

------

## å…­ã€ç®€å•æ€»ç»“ + ä¸‹ä¸€æ­¥å»ºè®®

3.3 ä½ éœ€è¦å…ˆç‰¢ç‰¢è®°ä½è¿™å‡ ä¸ªâ€œå‹ç¼©ç‰ˆâ€ç»“è®ºï¼š

1. **unordered_map**
   - åº•å±‚å“ˆå¸Œè¡¨ï¼Œå¹³å‡å¢åˆ æŸ¥ O(1)ï¼ŒKey æ— åºï¼›
   - é»˜è®¤ä¼˜å…ˆé€‰å®ƒï¼›
   - `operator[]` ä¼šåœ¨ key ä¸å­˜åœ¨æ—¶é¡ºæ‰‹æ’å…¥æ–°å…ƒç´ ï¼ˆé»˜è®¤å€¼ï¼‰ï¼ŒåªæŸ¥ç”¨ `find`ã€‚
2. **map**
   - åº•å±‚å¹³è¡¡æ ‘ï¼ˆçº¢é»‘æ ‘ï¼‰ï¼Œæœ‰åºï¼Œå¢åˆ æŸ¥ O(log n)ï¼›
   - éœ€è¦æŒ‰ Key æ’åºéå† / ç”¨ `lower_bound` æ—¶é€‰ mapã€‚
3. **è‡ªå®šä¹‰ Key**
   - `map<è‡ªå®šä¹‰Key, ...>`ï¼šå®šä¹‰ `operator<`ï¼ˆé€šå¸¸ç”¨å­—å…¸åºï¼‰ï¼›
   - `unordered_map<è‡ªå®šä¹‰Key, ...>`ï¼šå®šä¹‰ `operator==` å’Œ `hash` å‡½æ•°ã€‚
4. å’Œå‰é¢å†…å®¹çš„è”åŠ¨ï¼š
   - éå†ç”¨ï¼š`for (const auto& [k, v] : mp)`ï¼›
   - ç»Ÿè®¡é¢‘æ¬¡ï¼š`unordered_map<Key, int> cnt; ++cnt[key];`ï¼›
   - æƒ³è¦æ’åºï¼šæ‹·åˆ° `vector` é‡Œï¼Œå† `std::sort` + lambdaã€‚

------

### å¯ä»¥è¯•ç€åšçš„å°ç»ƒä¹ ï¼ˆä½ è¦æ˜¯æœ‰åŠ²å„¿çš„è¯ ğŸ˜„ï¼‰

1. å†™ä¸€ä¸ªå‡½æ•°ï¼Œç”¨ `unordered_map<char,int>` ç»Ÿè®¡å­—ç¬¦ä¸²æ¯ä¸ªå­—ç¬¦å‡ºç°æ¬¡æ•°ï¼Œè¿”å›é¢‘æ¬¡ mapï¼Œéå†ç”¨èŒƒå›´ for + `auto`ï¼›
2. ä¿®æ”¹ä½ æŸé“å›¾è®ºé¢˜çš„ä»£ç ï¼ŒæŠŠï¼š
   - `vector<vector<pair<int,int>>>` æ”¹æˆ `unordered_map<int, vector<pair<int,int>>>`ï¼Œè¡¨ç¤ºç¨€ç–å›¾ï¼ˆåªæœ‰éƒ¨åˆ†èŠ‚ç‚¹å‡ºç°çš„æƒ…å†µï¼‰ï¼›
3. å†™ä¸€ä¸ª `struct Key { int u, v; };`ï¼Œè®©å®ƒèƒ½å½“ `std::map<Key,int>` çš„ keyï¼ˆå†™ `operator<`ï¼‰ã€‚

ä½ å¯ä»¥éšä¾¿æŒ‘ä¸€ä¸ªç»ƒä¹ å†™å‡ºæ¥å‘ç»™æˆ‘ï¼Œæˆ‘ä¸€é¢˜ä¸€é¢˜å¸®ä½ ä»â€œå†™å¾—å¯¹â€å˜æˆâ€œå†™å¾—åƒé¢ç»é‡Œå±•ç¤ºç”¨çš„é‚£ç§â€ï¼Œé¡ºä¾¿æŠŠ `map / unordered_map` å½»åº•å˜æˆä½ çš„â€œåå°„åŠ¨ä½œâ€ã€‚