好，正式开刷 1.1 啦，这一块搞明白了，你后面看“栈溢出、悬空指针、new/delete、临时对象”等都会顺很多。

我分成三块讲：

1. C++ 程序大致的“内存地图”
2. 局部变量的生命周期
3. 作用域 scope vs 生命周期 lifetime（最容易混）

------

## 一、C++ 程序的“内存地图”

先给你一个经典示意图（逻辑上的，不是物理地址）：

```text
高地址
┌───────────────────────┐
│   栈区 (stack)        │  ← 函数调用、局部变量、参数
├───────────────────────┤
│   堆区 (heap)         │  ← new/malloc 出来的对象
├───────────────────────┤
│ 全局/静态区 (data/bss)│  ← 全局变量、static 变量
├───────────────────────┤
│ 文字常量区 (rodata)   │  ← 字符串字面量、常量表
├───────────────────────┤
│ 代码区 (text)         │  ← 可执行指令
└───────────────────────┘
低地址
```

### 1. 栈区（stack）

特点：

- **自动分配、自动释放**：函数调用时分配栈帧，函数返回时整块销毁
- 存放：
  - 函数参数（值传递的拷贝）
  - 函数内的局部变量
  - 返回地址等
- 空间一般不大，但**分配极快**

例子：

```cpp
void foo(int x) {
    int y = 10;    // y 在栈上
}                  // foo 返回时，y 和 x 一起销毁

int main() {
    int a = 5;     // a 在栈上
    foo(a);
}
```

这里的 `a`、`x`、`y` 全都是在栈上。

------

### 2. 堆区（heap）

特点：

- 由你自己控制：`new/delete` 或 `malloc/free`
- 生命周期**不跟函数绑定**，你不释放它就一直在
- 空间大，但分配回收相对慢

例子：

```cpp
int* p = new int(10); // 在堆上申请一个 int，值为 10
// ...
delete p;             // 手动释放
p = nullptr;          // 防止悬空指针
```

这里：

- `p` 本身在栈上（普通局部变量）
- `*p` 指向的那块内存（存 10 的地方）在堆上

> 程序跑很久（比如 EDA 工具）却不 delete，就会“内存泄漏”。

------

### 3. 全局 / 静态区（global / static）

特点：

- 程序开始就分配，程序结束才释放（**整个进程生命周期**）
- 存放：
  - 全局变量
  - `static` 修饰的变量（无论在函数内还是类内）

例子：

```cpp
int g = 0;        // 全局变量：全局/静态区

void foo() {
    static int cnt = 0; // 也是全局/静态区的一部分
    cnt++;
}
```

`g` 和 `cnt` 都是“静态存储期对象”，从程序启动到结束一直存在。

------

### 4. 文字常量区（read-only data）

特点：

- 只读区域，存放**字面量常量**
- 比如字符串字面量 `"hello"` 就放在这里

例子：

```cpp
const char* s = "hello";
```

- `"hello"` 这 6 个字符（含 `\0`）在常量区
- `s` 本身在栈上，存的是那块常量区的地址

------

### 5. 代码区（text）

特点：

- 存机器指令（编译后的代码）
- 一般只读

对你来说，理解：**函数的代码本身存这里** 就够用了。

------

## 二、局部变量的生命周期（lifetime）

“局部变量”大多是在栈上分配的（注意：并不绝对，但对现在来说可以这么理解）。

例子 1：

```cpp
void foo() {
    int a = 10;
}  // 离开 foo 作用域，a 的生命周期结束，栈帧被回收
```

- `a` 的 **作用域**：在 `foo` 函数代码块 `{ ... }` 内
- `a` 的 **生命周期**（生存期）：从执行到 `int a = 10;` 这一行开始，到 `foo` 结束为止

例子 2（指针悬空经典错误）：

```cpp
int* getPtr() {
    int x = 10;
    return &x;   // ❌ 返回局部变量地址
}

int main() {
    int* p = getPtr(); // p 指向了一块已经无效的栈内存
    // *p 是未定义行为（UB）
}
```

问题在于：

- `x` 在栈上，函数返回时，对应栈帧销毁，`x` 的那块区域就无效了
- 你把 `&x` 赋给了外面的指针 `p` → 成了“悬空指针”

这类问题在 **图遍历 / DFS / BFS / 递归** 里非常容易踩雷。

------

## 三、作用域（scope） vs 生命周期（lifetime）

这俩是很多人混的概念，尤其是 `static` 局部变量：

> “看起来在一个函数里，为什么不会随着函数结束销毁？”

我们先给定义：

### 1）作用域（scope）

> 在哪一段代码里**可以看见这个名字**。

比如：

```cpp
int g = 0;    // g 的作用域：整个文件（若加 static，则是编译单元）

void foo() {
    int a = 10;   // a 的作用域：foo 函数体内部
    {
        int b = 20;   // b 的作用域：这个内部大括号里
    }
    // 这里看不到 b 了
}
```

scope 完全是“**名字可见区域**”的概念。

------

### 2）生命周期（lifetime / storage duration）

> 对象在内存中存活的时间段。

根据存储期，大致三类你要记住：

1. **自动存储期（automatic storage）**
   - 一般就是“栈上局部变量”
   - 进入作用域 → 分配；离开作用域 → 销毁
2. **静态存储期（static storage）**
   - 全局变量、`static` 变量
   - 程序整个运行期间都存在
3. **动态存储期（dynamic storage）**
   - `new` / `malloc` 出来的
   - 由你自己控制 `delete/free` 时间

------

### 3）重点：作用域和生命周期可以不一样

最典型的例子：

```cpp
void foo() {
    static int cnt = 0;
    cnt++;
    cout << cnt << endl;
}
```

- `cnt` 的 **作用域**：只能在 `foo` 里可见
- `cnt` 的 **生命周期**：从程序启动到结束（静态存储期）

所以你多次调用 `foo()`：

```cpp
foo(); // 1
foo(); // 2
foo(); // 3
```

`cnt` 会记住之前的值，因为它没有在函数结束时被销毁。

------

### 4）再看一个：堆对象 & 指针作用域不等于对象生命周期

```cpp
int* create() {
    int* p = new int(10); // 堆上对象
    return p;             // 拷贝指针出去
}                         // p 离开作用域销毁，但 *p 还活着

int main() {
    int* q = create();    // q 现在指向堆上那块 int
    // ...
    delete q;             // 这里才释放堆内存
}
```

- 指针 `p` 的**作用域**：create 内
- 指针 `q` 的**作用域**：main 内
- `*p` / `*q` 指向的那块堆内存的**生命周期**：从 `new` 开始，到你 `delete` 时结束

**对象的生命周期不一定跟指向它的指针一个命运。**

------

## 🔚 小结（这一节你需要记住的点）

你今天这块的“八股版总结”可以直接背这几条：

1. C++ 进程内存大致分：**栈 / 堆 / 全局静态区 / 常量区 / 代码区**
2. 栈：存局部变量和参数，函数返回时自动释放
3. 堆：`new` / `delete` 管理，不手动释放就一直存在
4. 全局/静态区：程序整个运行期都存在（全局变量 + static 变量）
5. 常量区：放字面量常量，比如字符串 `"hello"`
6. 作用域（scope）是“**名字符号能看见的区域**”
7. 生命周期（lifetime）是“**对象实际活着的时间**”
8. `static` 局部变量：**作用域在函数内，生命周期贯穿整个程序**
9. 返回局部变量地址是经典错误：函数结束后栈帧销毁 → 悬空指针

------

如果你愿意，明天我们可以继续：

- 学 **1.2 指针**（系统把 p / *p / &p / 数组指针 / 指针数组全串起来）
- 或者我也可以先给你出几道今天这块的小题（比如“这个变量在哪块内存区”“哪一行开始/结束生命周期”等）让你自测一下。

你想下一步怎么搞：做几道题检查一下，还是直接学 1.2？



好的，我给你出一套 **“C++ 内存模型·面试级试卷（专为 EDA / 算法岗）”**
 覆盖你今天学的全部重点：
 **栈 / 堆 / 全局区 / 常量区 / 代码区 / 生命周期 / 作用域 / 悬空指针 / 临时对象**

格式依然是：

- **不写答案**
- 全部是 **面试官真实会问的风格**
- 题目难度循序渐进
- 你答完我逐题帮你解析

------

# 🧪【C++ 内存模型·面试试卷（无代码实现）】

**难度：中等偏上（算法岗/EDA岗）**

------

# 📘 Part A：概念判断（10题）

### **1.**

下面哪些存储在 **栈区**？
 A. 函数参数
 B. 局部变量
 C. new 出来的对象
 D. static 局部变量

------

### **2.**

下面哪些属于 **静态存储期对象**？
 A. 全局变量
 B. static 变量
 C. 常量字符串 `"abc"`
 D. 函数返回值

------

### **3.**

下面哪些属于 **常量区（rodata）**？
 A. `const int x = 10;`
 B. `"hello"`
 C. `int arr[3] = {1,2,3}`
 D. `const char* p = "Hi"`

------

### **4.**

关于堆区（heap），下列说法正确的是：
 A. 堆由系统自动释放
 B. 堆内存需要手动 delete
 C. 堆空间有限，会用完
 D. 堆比栈分配速度快

------

### **5.**

下面哪些操作会导致 **未定义行为（UB）**？
 A. 返回局部变量引用
 B. 返回局部变量地址
 C. delete 两次
 D. delete nullptr

------

### **6.**

下面哪种变量在作用域结束后仍然存在？
 A. 普通局部变量
 B. static 局部变量
 C. 函数参数
 D. 堆对象

------

### **7.**

下面哪些属于“临时对象”（temporary）？
 A. `5`
 B. `"hello"`
 C. `std::string("abc")`
 D. `a + b`（a,b为int）

------

### **8.**

下列哪项是“作用域（scope）”而不是“生命周期（lifetime）”？
 A. 变量名能被访问的范围
 B. 对象在内存中活着的时间
 C. static 变量只能在定义处使用
 D. 堆对象在 new 到 delete 之间活着

------

### **9.**

下面哪条关于字符串 `"abc"` 的叙述是正确的？
 A. 存在栈区
 B. 存在常量区
 C. 可以通过 `*(char*)"abc"` 修改
 D. 它的生命周期是整个程序

------

### **10.**

为什么局部变量不能返回地址？
 A. 因为栈会被覆盖
 B. 因为局部变量存储在堆里
 C. 因为局部变量生命周期在函数结束时结束
 D. 因为 C++ 语法禁止

------

# 📘 Part B：输出与内存区判断（8题）

### **11.**

指出以下四个变量分别在哪块内存区：

```cpp
int a = 10;
static int b = 20;
int* p = new int(30);
const char* s = "hi";
```

------

### **12.**

下面代码中有哪些变量在返回后依然存在？

```cpp
int* foo() {
    int x = 1;
    static int y = 2;
    int* p = new int(3);
    return &y; // 返回什么无所谓，本题问变量本身
}
```

------

正确答案：

| 变量            | 是否在函数返回后仍然存在           |
| --------------- | ---------------------------------- |
| x               | ❌ 不存在（栈变量，随函数结束销毁） |
| y               | ✔ 一直存在（static 区）            |
| p 指向的内存 *p | ✔ 存在（堆）                       |
| p（栈指针本身） | ❌ p 在栈里，会销毁                 |

你写的 **p** 不完全正确，因为：

- p（指针变量本身） → 在 foo 的栈里，会消亡
- *p（指向的堆内存） → 会继续存在

如果你想表达 `*p` 存活，你应该写：

> y、*p

### **13.**

下面代码执行会发生什么？

```cpp
int* foo() {
    int x = 10;
    return &x;
}

int main() {
    int* p = foo();
    cout << *p << endl;
}
```

------

### **14.**

下面的字符串生命周期问题：

```cpp
const char* s1 = "hello";
std::string s2 = std::string("world");
```

问：二者分别存在哪？生命周期各是多久？

正确答案：

| 变量                | 存储位置      | 生命周期     |
| ------------------- | ------------- | ------------ |
| `"hello"`           | 常量区 rodata | 整个程序     |
| s1（指针变量）      | 栈            | 随函数结束   |
| `"world"`（字面量） | 常量区        |              |
| s2（string 对象）   | 栈（本身）    | 随作用域结束 |
| s2 内部的字符缓冲区 | 堆            | 随析构释放   |

关键点：

✔ `"hello"` 是字面量 → 常量区

❌ `s2` 不在常量区，它是对象 → 在栈

✔ 但 s2 的内部缓冲区（"world" 的复制）在堆

你以后会经常碰到这个问题。

------

### **15.**

下面的 b 是否安全？

```cpp
int* foo() {
    int a = 10;
    int* b = &a;
    return b;
}
```

---

❌ 完全不安全：这叫“悬空指针（dangling pointer）”

原因：

- `a` 是栈变量，生命周期结束于 foo 返回时
- b = &a
- 返回 b 就是返回“指向已死亡的对象的指针”

```cpp
int* p2;      // p2 没初始化，里面是垃圾地址
{
    int x = 20;
    *p2 = x;  // 直接对垃圾地址解引用写入 → UB
}
```

- `p2` 此时是**未初始化的野指针**
- `*p2 = x;`：对一个**野指针解引用写入** → 完全未定义行为（要么崩溃，要么乱写内存）

跟 x 的生命周期关系都不大了，这里最核心的问题变成：

> 你在对一个 **未指向任何有效内存的指针解引用**，这是最危险的一种 UB。

### **16.**

下面哪些指针安全、哪些是悬空的？

```cpp
int* p1;
p1 = new int(10);

int* p2;
{
    int x = 20;
    p2 = &x;
}

int* p3 = nullptr;

int* p4 = &(*p1);
```

------

| 指针 | 是否安全？ | 原因                                      |
| ---- | ---------- | ----------------------------------------- |
| p1   | ✔ 安全     | 指向 new 出来的堆内存                     |
| p2   | ❌ 不安全   | 指向已销毁的局部变量 x（悬空指针）        |
| p3   | ✔ 安全     | nullptr 合法                              |
| p4   | ✔ 安全     | &(*p1) 等价于 p1，只要 p1 安全，p4 就安全 |

```cpp
int foo() {
    int a = 10;
    int* b = &a;
    return *b;
}
```

执行顺序是：

1. 进入 foo，栈上分配 a、b
2. `b = &a;`，此时 b 指向 a（还活着）
3. `return *b;`：
   - 先计算 `*b` → 访问 a 的值（此时 a 还在栈上）
   - 把这个值（10）**拷贝**到返回值里面
4. 函数返回，栈帧销毁，a 和 b 都死了
    但没关系 —— **调用者拿到的是一个纯值 10**，跟 a/b 已经没有任何联系了

所以这是安全的，因为：

> 我们没有“把 a 的地址带出去”，
>  而是在 a 活着的时候 **拷贝了一份它的值** 返回。

### **17.**

指出 x 的作用域（scope） 与生命周期（lifetime）：

```cpp
void foo() {
    static int x = 0;
    x++;
}
```

------

### **18.**

堆对象一定比栈对象活得久吗？为什么？

------

# 📘 Part C：深度理解题（5题）

### **19.**

解释 “作用域（scope）” 和 “生命周期（lifetime）” 的区别，并给一个它们不一致的例子。

------

### **20.**

为什么 new/delete 会比栈分配更慢？
 请给出两个原因。

理由 1：**栈分配是“挪指针”，堆分配是“找空间”**

栈分配：

```
void foo() {
    int x;  // 编译器知道栈上要预留多少空间，只是移动栈指针
}
```

- 栈是一个连续的内存区域，分配就是移动一个栈顶指针
- 开个栈帧、释放栈帧 → 指针加加减减，极快

堆分配（new）：

```
int* p = new int(10);
```

- 堆管理器要在一大块内存里**找一块够用的空闲区域**
- 可能需要维护链表 / 红黑树 / bitmap 等结构
- 完成分配后还要记录“这块地址现在被谁占用了”

> 👉 简单理解：
>  栈是“预分配 + 顺序使用”，堆是“动态找坑 + 管理空位”。

理由 2：**堆分配需要更复杂的线程安全 & 碎片管理**

- 多线程时，堆分配可能还要加锁（或用更复杂的无锁算法）
- 堆内存会产生碎片，需要维护内部数据结构
- 栈因为每个线程自己一块，进出非常简单

所以总结一句可背的：

> **栈分配是简单的指针移动，几乎零成本；
>  堆分配需要复杂的管理和查找，所以通常慢得多。**

### **21.**

为什么下面代码中，`y` 可以在函数返回后继续访问？

```cpp
int& foo() {
    static int y = 100;
    return y;
}
```

------

对比一下不安全的版本：

```
int& foo() {
    int x = 10;
    return x;    // ❌ 悬空引用
}
```

### **22.**

为什么下面代码是安全的？

```cpp
const int& r = 5;
```

为什么引用可以绑定到字面量？

------

编译器实际会偷偷做这件事：

```
int __temp = 5;         // 生成一个临时变量
const int& r = __temp;  // r 引用这个临时变量
```

特殊规则是：

> **const 引用绑定到一个临时量时，会延长这个临时量的生命周期，使其至少活到引用的作用域结束。**

### **23.**

解释什么叫“悬空指针”（dangling pointer），并给出两个不同的例子。

------

悬空指针（dangling pointer）是指：指向一块“原来有效，但现在已经无效”的内存的指针。

例子 1：返回局部变量地址

```
int* foo() {
    int x = 10;   // x 在栈上
    return &x;    // ❌ 返回局部变量地址
}

int main() {
    int* p = foo();  // p 是悬空指针
    cout << *p << endl;  // UB
}
```

- 栈帧消失，x 死亡
- 但 p 仍然指着原来 x 的位置 → 悬空指针

例子 2：delete 后不置 nullptr

```
int* p = new int(10);
delete p;        // 堆内存被释放(delete删除内存)
*p = 20;         // ❌ 对已释放内存写入 → UB
```

或者：

```
int* p = new int(10);
int* q = p;
delete p;        // 这里释放了那块内存
cout << *q;      // ❌ q 是悬空指针
```

这就是典型的“堆对象消失，但还有指针指着它”。

------

# 🧪 **Part D：基础强化题（9题）**

**考察：内存区、生命周期、地址 vs 值、new/delete**

### **D1.**

下面每个变量分别位于哪块内存？（栈 / 堆 / 全局静态区 / 常量区）

```cpp
int a = 10;
static int b = 20;
const char* s = "hello";
int* p = new int(30);
```

------

### **D2.**

下面哪个是“对象”，哪个是“指针变量”，哪个是“字面量”？
 并标注它们分别在哪块内存？

```cpp
int* p = new int(5);
```

⭐ 什么是“对象”？（你必须弄懂）

> **对象 = 在内存中实际存在的那块空间（存放值）**

例如：

```
int x = 10;
```

- x 本身就是对象，它是一块实际内存区域

而 new 出来的对象是：

```
int* p = new int(5);
```

- 在堆上开辟了一块内存，里面放着 5
- 这块内存 = “对象”

⭐ 指针不是对象

- 指针变量 `p` 是一个 **变量**（存在栈）
- `new int(5)` 才是真正的 **对象**（存在堆）

你之前模糊的点已经完全解决了。

------

### **D3.**

执行 delete p 后，下面哪些是“有效的”，哪些是“无效的”（UB）？

```cpp
*p
p
p == nullptr
*p = 10
delete p
```

------

### **D4.**

下面哪些代码导致悬空指针？

A.

```cpp
int* foo() {
    int x = 10;
    return &x;
}
```

B.

```cpp
int* foo() {
    static int x = 10;
    return &x;
}
```

C.

```cpp
int* p = new int(5);
delete p;
int x = *p;
```

D.

```cpp
int x = 10;
int* p = &x;
```

------

| 表达式         | 是否安全？                 | 为什么？                       |
| -------------- | -------------------------- | ------------------------------ |
| `*p`           | ❌ 不安全                   | 悬空指针解引用                 |
| `p`            | ✔ 安全                     | p 只是个变量，访问它本身没问题 |
| `p == nullptr` | ✔ 安全，但几乎一定是 false | delete 不会自动把 p 置空       |
| `*p = 10`      | ❌ 不安全                   | 对已释放内存写入               |
| `delete p`     | ❌ UB（double delete）      | 一块内存不能被释放两次         |

### **D5.**

下面哪段代码安全？哪段不安全？为什么？

A.

```cpp
int* foo() {
    int x = 10;
    return new int(x);
}
```

B.

```cpp
int* foo() {
    int x = 10;
    return &x;
}
```

C.

```cpp
int foo() {
    int x = 10;
    return x;
}
```

------

### **D6.**

下面哪些变量在“foo 返回后依然存在”？

```cpp
int* foo() {
    int a = 1;
    static int b = 2;
    int* p = new int(3);
    return p;
}
```

------

> return x 是拷贝，不依赖 x 的生命周期。

返回值存放在 **调用者栈帧里的一块位置**。

你现在完全懂了：

> **只要是“按值返回”，就是安全的。悬空问题只会出现在返回“地址 / 引用”时。**

### **D7.**

为什么下面这一句是安全的？

```cpp
const int& r = 5;
```

------

### **D8.**

为什么下面这一句不安全？

```cpp
int& r = 5;
```

------

### **D9.**

以下哪些东西是“左值”？哪些是“右值”？
 （左值可以取地址，有名字；右值是临时值）

```
10
"hi"
a
a + 1
std::string("x")
const int x = 5
```

------

**左值**：可以取地址、有名字、持久性

**右值**：临时值、无法取地址、表达式结果

| 表达式             | 左值 / 右值        | 为什么                                       |
| ------------------ | ------------------ | -------------------------------------------- |
| `10`               | 右值               | 字面量                                       |
| `"hi"`             | **左值**（注意！） | 字符串字面量在常量区，有固定地址，可以取地址 |
| `a`                | 左值               | 有名字，可以取地址                           |
| `a + 1`            | 右值               | 表达式临时结果                               |
| `std::string("x")` | 右值               | 临时对象                                     |
| `const int x = 5`  | x 是左值           | 变量                                         |

# 🧪 **Part E：场景理解题（深度理解）**

**你真正需要掌握到这种程度。**

------

### **E1. 内存图题：**

画出执行时各变量在内存中的位置（栈/堆/静态区/常量区）：

```cpp
int a = 10;

int* foo() {
    static int s = 20;
    int x = 30;
    int* p = new int(40);
    return p;
}

int main() {
    int* q = foo();
    return 0;
}
```

------

### **E2. 下面代码是否安全？为什么？**

```cpp
int* foo() {
    static int s = 10;
    return &s;
}

int& bar() {
    static int s = 20;
    return s;
}

int main() {
    int* p = foo();
    int& r = bar();
    *p = 100;
    r = 200;
    cout << *p << " " << r;
}
```

------

### **E3. 为什么下面这段代码会崩溃？**

```cpp
int* p = nullptr;
*p = 10;
```

结论：

- `*p = 10;` → **未定义行为（UB）**，几乎一定崩
- `nullptr` 和 `NULL`（在 C++ 里一般是 `0` / `0L`）在这里作用一样 —— **都是“空地址”**
- 解引用空指针 = 试图访问地址 0 的内存 → 典型的“空指针解引用”崩溃

> 所以：`int* p = nullptr; *p = 10;` 和 `int* p = NULL; *p = 10;` 本质上一样，都是 UB。

**区别点：**

- `nullptr` 是 C++11 引入的**专门的空指针类型**
- `NULL` 本质是宏，一般是 `0`，类型上不那么安全

但这两段代码都会崩。

### **E4. 为什么这段代码也会崩溃，但原因和上一题不同？**

```cpp
int* p = new int(10);
delete p;
*p = 20;
```

提示：UB 的原因不一样。

关键点：

- `delete p;` **不会“清空那块内存内容”**，也不会“把 p 设为 nullptr”
- 它只是：把 `p` 指向的那块堆内存还给堆管理器 → 之后这块地址不再属于你
- 但 p 仍然保存着旧地址，只是变成了 **悬空指针**

**和 E3 的区别：**

- E3：**空指针解引用**（地址 0，本来就不指向有效内存）
- E4：**悬空指针解引用**（曾经有东西，现在已经 free 掉）

### **E5. 下面三组 return 哪些安全？哪些不安全？**

```cpp
int* foo1() {
    int x = 10; 
    return &x;
}

int foo2() {
    int x = 20;
    return x;
}

int& foo3() {
    int x = 30;
    return x;
}

int* foo4() {
    int* p = new int(40);
    return p;
}

int& foo5() {
    static int s = 50;
    return s;
}
```

------

**核心口诀：**

- 返回局部变量的地址/引用 → 一律危险
- 返回 static / 堆对象的地址/引用 → 安全（要管好释放）