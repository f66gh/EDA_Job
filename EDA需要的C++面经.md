下面给你一份 **“EDA 实习可直接背诵 / 理解的 C++ 八股 + 专项试题 + 详细解析”**
 👉 **不包含代码实现题**
 👉 可以在 **一周内背完**
 👉 针对 **EDA / 算法工程岗**（而非后端开发岗），所以我只保留“真正会被问到”的内容。

这份八股是我根据你目标岗位筛选后的精简版，不会有多继承模板元编程等你不需要的东西。

------

# 📘 第一部分：C++ 八股（背诵版）

## 1. 指针 vs 引用（必考）

**区别（必须背下）**：

1. **是否可以为 null**
   - 指针：可以为 nullptr
   - 引用：必须绑定对象，不能为 null
2. **能否重新绑定**
   - 指针：可改指向
   - 引用：一旦绑定不可更改
3. **语法**
   - 指针：访问用 `*` / `->`
   - 引用：像普通变量一样访问
4. **底层实现**
   - 引用通常用指针实现，但语义更安全（编译器保证不会是 null）
5. **函数参数使用场景**
   - 用指针：参数可能为空、不一定有对象
   - 用引用：一定存在对象、语义更清晰

------

## 2. const（绝对必考）

**四种 const 写法：**

1. `const int* p;`
   - 指向只读 int 的指针 → *p 不可改，p 可改指向
2. `int* const p = &x;`
   - 常量指针 → p 不可改指向，*p 可改
3. `const int* const p = &x;`
   - 都不能改
4. `const int& r = x;`
   - 常量引用，不可修改 r

**面试必问句**：

> “const 是修饰谁？看它右边最近的东西。”

------

## 3. 值传递 vs 引用传递 vs 指针传递

**值传递**

- 形参是实参的拷贝

**引用传递**

- 实参本体直接参与修改，不额外拷贝

**指针传递**

- 是值传递，只不过这个值是地址
- 可以通过修改 *p 修改实参，但不能改引用

------

## 4. inline（常问）

**inline 的作用：**

1. 减少函数调用开销（小函数用）
2. 编译期展开，不是运行时行为
3. 编译器可能拒绝 inline（例如递归）

------

## 5. static（必考）

1. **静态局部变量**
   - 全局生命周期
   - 只初始化一次
2. **静态成员变量**
   - 类共享
   - 类外定义：`int A::x = 0;`
3. **静态成员函数**
   - 不能访问非静态成员

------

## 6. struct vs class

**唯一区别：**

- struct 默认 public
- class 默认 private

**除此之外完全一样。**

------

## 7. new / delete vs malloc / free（EDA 特别在意）

| 特性              | new/delete   | malloc/free |
| ----------------- | ------------ | ----------- |
| 是否调用构造/析构 | ✔            | ✘           |
| 是否类型安全      | ✔            | ✘           |
| 返回类型          | 对象类型指针 | void*       |
| 失败时            | 抛异常       | 返回 NULL   |

------

## 8. RAII（EDA 必问）

资源获取即初始化（Resource Acquisition Is Initialization）

- 构造函数获取资源（内存/文件句柄/锁）
- 析构函数自动释放资源
- 防止忘记 free
- 用在智能指针、锁、文件读写中

------

## 9. 智能指针（背会 shared_ptr / unique_ptr）

### unique_ptr

- 独占
- 禁止复制，只能 move
- 最常用：`std::make_unique`

### shared_ptr

- 引用计数
- 可以共享
- 慎用，容易形成环

------

## 10. STL 六大组件（常问）

- 容器（vector, map, unordered_map, set…）
- 算法（sort, find, for_each…）
- 迭代器
- 仿函数（less, greater）
- 适配器（stack, queue）
- 分配器（allocator）

------

## 11. vector 原理（常问）

- 连续内存
- push_back 可能触发扩容
- capacity 以倍数增长（1.5 或 2 倍）
- 扩容会拷贝旧元素 → O(n)
- reserve() 可以减少扩容次数（性能关键）

------

## 12. map vs unordered_map（必记）

| 项目     | map      | unordered_map |
| -------- | -------- | ------------- |
| 底层     | 红黑树   | 哈希表        |
| 查找     | O(log n) | 平均 O(1)     |
| 遍历顺序 | 有序     | 无序          |
| 内存     | 少       | 多            |

EDA 图算法基本只用 **unordered_map**。

------

## 13. priority_queue（必考）

默认是 **大根堆**
 小根堆写法：

```cpp
priority_queue<int, vector<int>, greater<int>> pq;
```

------

# 📘 第二部分：高频知识点问答（背诵版）

下面每道题都很贴近 EDA 面试风格。

------

## Q1：引用为何必须初始化？

**答案：**
 引用必须指向一个已存在的对象。引用本质是一个别名，而别名必须从一开始就绑定对象。

------

## Q2：为什么引用不能重新绑定？

为了保持语义清晰：一旦绑定，它就是这个对象的名字，不能变。

底层通常存成 const 指针，使其不能重新指向其他对象。

------

## Q3：什么时候使用引用，什么时候用指针？

**用引用：**

- 必须有对象，不允许 null
- 修改调用者变量
- 参数传大对象避免拷贝（const T&）

**用指针：**

- 参数可能为空
- 动态分配对象
- 管理数组、内存块

------

## Q4：为什么 vector 扩容会导致迭代器失效？

因为扩容会申请新内存并把旧元素全量拷贝过去，原来的内存地址失效。

------

## Q5：什么是深拷贝 / 浅拷贝？

浅拷贝：只拷贝指针，不拷贝对象本体
 深拷贝：连对象所占内存一起复制

------

## Q6：shared_ptr 为什么不要循环引用？

因为 A 持有 B，B 持有 A，两者引用计数都不会归零，导致内存泄漏。

------

## Q7：为什么 unordered_map 查找是 O(1)？

因为哈希函数把 key 映射到桶，通过链表或开放寻址解决冲突。

------

## Q8：迭代器失效有哪些情况？

- vector 扩容
- 插入删除元素导致地址变化
- map/set erase 某个元素 → 该元素的迭代器失效

------

## Q9：为什么 new 会抛异常，而 malloc 不会？

new 的失败会抛 `std::bad_alloc`，而 malloc 返回 NULL。
 因为 new 是 C++ 语法层特性，语义更强。

------

## Q10：C++ 内存分区（需要能解释）

- 栈（函数局部变量）
- 堆（new/malloc）
- 全局/静态区
- 文字常量区
- 代码区

------

# 📘 第三部分：八股试题 + 标准解析（无代码题）

下面这些就是一周能背完的高频八股题。

------

## 【试题 1】

引用和指针有什么区别？为什么引用不能为 null？

**解析：**
 见八股第 1 部分，必记。

------

## 【试题 2】

`const int *p`、`int *const p`、`const int *const p` 分别代表什么？

**解析：**
 见 const 部分。

------

## 【试题 3】

为什么 vector 会扩容？扩容带来的问题是什么？

**解析：**

- 扩容策略：capacity 不够 → 申请更大空间 → 拷贝旧元素
- 问题：
  - 迭代器失效
  - 元素重新移动，影响性能
  - push_back 可能变成 O(n)

------

## 【试题 4】

为什么 unordered_map 查找速度是 O(1)？什么时候会变成 O(n)？

**解析：**

- 平均 O(1) → 哈希桶 + 链表/开放寻址
- 最坏 O(n) → 所有 key 都哈希到同一个桶（冲突严重）

------

## 【试题 5】

RAII 是什么？为什么 EDA 工具特别依赖它？

**解析：**

- 构造时获得资源，析构时释放
- 避免资源泄漏（CPU 密集型 C++ 工具特别依赖内存/句柄/锁释放）
- 在大型 C++ 工具链中避免忘记 delete，这很关键

------

## 【试题 6】

为什么 new 会调用构造函数，而 malloc 不会？

**解析：**

- new 是 C++ 语法，等价于 malloc + constructor
- malloc 只分配裸内存，不知道对象类型

------

## 【试题 7】

为什么 shared_ptr 会造成循环引用？

**解析：**

- 因为它使用引用计数
- A->B 和 B->A 会导致引用计数永不归零
- 内存无法释放

------

## 【试题 8】

什么情况下 vector 会使迭代器失效？

**解析：**

- 扩容
- 插入删除改变元素顺序
- clear 会所有迭代器失效

------

## 【试题 9】

map 和 unordered_map 区别是什么？为什么 Dijkstra 更推荐用 unordered_map？

**解析：**

- map：红黑树，有序，O(log n)
- unordered_map：哈希表，平均 O(1)
- Dijkstra 查找最短距离时频繁查表 → 优先 O(1)

------

## 【试题 10】

写出 C++ 内存分区，并说明局部变量和静态变量分别在哪？

**解析：**

- 栈：局部变量
- 堆：new
- 静态区：static / 全局变量
- 常量区：字符串字面量
- 代码区：可执行代码

------

# 📘 如果你愿意，我可以继续帮你：

- 给你做一份 **“一周 C++ 八股学习行动表”**
- 做一份 **“每天 20 题 C++ 八股快问快答”**
- 做一份 **EDA 实习专属 C++ 知识点纯背诵小册子（PDF版）**

你想让我继续补充哪部分？